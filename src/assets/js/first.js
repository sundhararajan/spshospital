"use strict"; (function (a, b) { a.behaviors.inputFocus = { attach: function (a) { b("input-focus", ".form-item", a).forEach(function (a) { var b = a, c = a.querySelector("input"); c && (c.addEventListener("focus", function () { b.classList.add("focused"), c.classList.add("filled"); }), c.addEventListener("blur", function () { "" === c.value ? (c.classList.remove("filled"), b.classList.remove("focused")) : c.classList.add("filled"); }), window.addEventListener("load", function () { c.value && (c.classList.add("filled"), b.classList.add("focused")); })); }); } }; })(Drupal, once);;
(function ($, Drupal) { Drupal.theme.progressBar = function (id) { const escapedId = Drupal.checkPlain(id); return (`<div id="${escapedId}" class="progress" aria-live="polite">` + '<div class="progress__label">&nbsp;</div>' + '<div class="progress__track"><div class="progress__bar"></div></div>' + '<div class="progress__percentage"></div>' + '<div class="progress__description">&nbsp;</div>' + '</div>'); }; Drupal.ProgressBar = function (id, updateCallback, method, errorCallback) { this.id = id; this.method = method || 'GET'; this.updateCallback = updateCallback; this.errorCallback = errorCallback; this.element = $(Drupal.theme('progressBar', id)); }; $.extend(Drupal.ProgressBar.prototype, { setProgress(percentage, message, label) { if (percentage >= 0 && percentage <= 100) { $(this.element).find('div.progress__bar').each(function () { this.style.width = `${percentage}%`; }); $(this.element).find('div.progress__percentage').html(`${percentage}%`); } $('div.progress__description', this.element).html(message); $('div.progress__label', this.element).html(label); if (this.updateCallback) this.updateCallback(percentage, message, this); }, startMonitoring(uri, delay) { this.delay = delay; this.uri = uri; this.sendPing(); }, stopMonitoring() { clearTimeout(this.timer); this.uri = null; }, sendPing() { if (this.timer) clearTimeout(this.timer); if (this.uri) { const pb = this; let uri = this.uri; if (!uri.includes('?')) uri += '?'; else uri += '&'; uri += '_format=json'; $.ajax({ type: this.method, url: uri, data: '', dataType: 'json', success(progress) { if (progress.status === 0) { pb.displayError(progress.data); return; } pb.setProgress(progress.percentage, progress.message, progress.label); pb.timer = setTimeout(() => { pb.sendPing(); }, pb.delay); }, error(xmlhttp) { const e = new Drupal.AjaxError(xmlhttp, pb.uri); pb.displayError(`<pre>${e.message}</pre>`); } }); } }, displayError(string) { const error = $('<div class="messages messages--error"></div>').html(string); $(this.element).before(error).hide(); if (this.errorCallback) this.errorCallback(this); } }); })(jQuery, Drupal);;
/* @license MIT https://raw.githubusercontent.com/muicss/loadjs/4.3.0/LICENSE.txt */
loadjs = function () { var h = function () { }, o = {}, c = {}, f = {}; function u(e, n) { if (e) { var t = f[e]; if (c[e] = n, t) for (; t.length;)t[0](e, n), t.splice(0, 1) } } function l(e, n) { e.call && (e = { success: e }), n.length ? (e.error || h)(n) : (e.success || h)(e) } function p(t, r, i, s) { var o, e, u, n = document, c = i.async, f = (i.numRetries || 0) + 1, l = i.before || h, a = t.replace(/[\?|#].*$/, ""), d = t.replace(/^(css|img|module|nomodule)!/, ""); if (s = s || 0, /(^css!|\.css$)/.test(a)) (u = n.createElement("link")).rel = "stylesheet", u.href = d, (o = "hideFocus" in u) && u.relList && (o = 0, u.rel = "preload", u.as = "style"); else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(a)) (u = n.createElement("img")).src = d; else if ((u = n.createElement("script")).src = d, u.async = void 0 === c || c, e = "noModule" in u, /^module!/.test(a)) { if (!e) return r(t, "l"); u.type = "module" } else if (/^nomodule!/.test(a) && e) return r(t, "l"); !(u.onload = u.onerror = u.onbeforeload = function (e) { var n = e.type[0]; if (o) try { u.sheet.cssText.length || (n = "e") } catch (e) { 18 != e.code && (n = "e") } if ("e" == n) { if ((s += 1) < f) return p(t, r, i, s) } else if ("preload" == u.rel && "style" == u.as) return u.rel = "stylesheet"; r(t, n, e.defaultPrevented) }) !== l(t, u) && n.head.appendChild(u) } function t(e, n, t) { var r, i; if (n && n.trim && (r = n), i = (r ? t : n) || {}, r) { if (r in o) throw "LoadJS"; o[r] = !0 } function s(n, t) { !function (e, r, n) { var t, i, s = (e = e.push ? e : [e]).length, o = s, u = []; for (t = function (e, n, t) { if ("e" == n && u.push(e), "b" == n) { if (!t) return; u.push(e) } --s || r(u) }, i = 0; i < o; i++)p(e[i], t, n) }(e, function (e) { l(i, e), n && l({ success: n, error: t }, e), u(r, e) }, i) } if (i.returnPromise) return new Promise(s); s() } return t.ready = function (e, n) { return function (e, t) { e = e.push ? e : [e]; var n, r, i, s = [], o = e.length, u = o; for (n = function (e, n) { n.length && s.push(e), --u || t(s) }; o--;)r = e[o], (i = c[r]) ? n(r, i) : (f[r] = f[r] || []).push(n) }(e, function (e) { l(n, e) }), t }, t.done = function (e) { u(e, []) }, t.reset = function () { o = {}, c = {}, f = {} }, t.isDefined = function (e) { return e in o }, t }();;
/* @license GPL-2.0-or-later https://www.drupal.org/licensing/faq */
Drupal.debounce = function (func, wait, immediate) { let timeout; let result; return function (...args) { const context = this; const later = function () { timeout = null; if (!immediate) result = func.apply(context, args); }; const callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) result = func.apply(context, args); return result; }; };;
(function (Drupal, debounce) { let liveElement; const announcements = []; Drupal.behaviors.drupalAnnounce = { attach(context) { if (!liveElement) { liveElement = document.createElement('div'); liveElement.id = 'drupal-live-announce'; liveElement.className = 'visually-hidden'; liveElement.setAttribute('aria-live', 'polite'); liveElement.setAttribute('aria-busy', 'false'); document.body.appendChild(liveElement); } } }; function announce() { const text = []; let priority = 'polite'; let announcement; const il = announcements.length; for (let i = 0; i < il; i++) { announcement = announcements.pop(); text.unshift(announcement.text); if (announcement.priority === 'assertive') priority = 'assertive'; } if (text.length) { liveElement.innerHTML = ''; liveElement.setAttribute('aria-busy', 'true'); liveElement.setAttribute('aria-live', priority); liveElement.innerHTML = text.join('\n'); liveElement.setAttribute('aria-busy', 'false'); } } Drupal.announce = function (text, priority) { announcements.push({ text, priority }); return debounce(announce, 200)(); }; })(Drupal, Drupal.debounce);;
((Drupal) => { Drupal.Message = class { constructor(messageWrapper = null) { if (!messageWrapper) this.messageWrapper = Drupal.Message.defaultWrapper(); else this.messageWrapper = messageWrapper; } static defaultWrapper() { let wrapper = document.querySelector('[data-drupal-messages]') || document.querySelector('[data-drupal-messages-fallback]'); if (!wrapper) { wrapper = document.createElement('div'); document.body.appendChild(wrapper); } if (wrapper.hasAttribute('data-drupal-messages-fallback')) { wrapper.removeAttribute('data-drupal-messages-fallback'); wrapper.classList.remove('hidden'); } wrapper.setAttribute('data-drupal-messages', ''); return wrapper.innerHTML === '' ? Drupal.Message.messageInternalWrapper(wrapper) : wrapper.firstElementChild; } static getMessageTypeLabels() { return { status: Drupal.t('Status message'), error: Drupal.t('Error message'), warning: Drupal.t('Warning message') }; } add(message, options = {}) { if (!options.hasOwnProperty('type')) options.type = 'status'; if (typeof message !== 'string') throw new Error('Message must be a string.'); Drupal.Message.announce(message, options); options.id = options.id ? String(options.id) : `${options.type}-${Math.random().toFixed(15).replace('0.', '')}`; if (!Drupal.Message.getMessageTypeLabels().hasOwnProperty(options.type)) { const { type } = options; throw new Error(`The message type, ${type}, is not present in Drupal.Message.getMessageTypeLabels().`); } this.messageWrapper.appendChild(Drupal.theme('message', { text: message }, options)); return options.id; } select(id) { return this.messageWrapper.querySelector(`[data-drupal-message-id^="${id}"]`); } remove(id) { return this.messageWrapper.removeChild(this.select(id)); } clear() { Array.prototype.forEach.call(this.messageWrapper.querySelectorAll('[data-drupal-message-id]'), (message) => { this.messageWrapper.removeChild(message); }); } static announce(message, options) { if (!options.priority && (options.type === 'warning' || options.type === 'error')) options.priority = 'assertive'; if (options.announce !== '') Drupal.announce(options.announce || message, options.priority); } static messageInternalWrapper(messageWrapper) { const innerWrapper = document.createElement('div'); innerWrapper.setAttribute('class', 'messages__wrapper'); messageWrapper.insertAdjacentElement('afterbegin', innerWrapper); return innerWrapper; } }; Drupal.theme.message = ({ text }, { type, id }) => { const messagesTypes = Drupal.Message.getMessageTypeLabels(); const messageWrapper = document.createElement('div'); messageWrapper.setAttribute('class', `messages messages--${type}`); messageWrapper.setAttribute('role', type === 'error' || type === 'warning' ? 'alert' : 'status'); messageWrapper.setAttribute('data-drupal-message-id', id); messageWrapper.setAttribute('data-drupal-message-type', type); messageWrapper.setAttribute('aria-label', messagesTypes[type]); messageWrapper.innerHTML = `${text}`; return messageWrapper; }; })(Drupal);;
(function ($, window, Drupal, drupalSettings, loadjs, { isFocusable, tabbable }) { Drupal.behaviors.AJAX = { attach(context, settings) { function loadAjaxBehavior(base) { const elementSettings = settings.ajax[base]; if (typeof elementSettings.selector === 'undefined') elementSettings.selector = `#${base}`; once('drupal-ajax', $(elementSettings.selector)).forEach((el) => { elementSettings.element = el; elementSettings.base = base; Drupal.ajax(elementSettings); }); } Object.keys(settings.ajax || {}).forEach(loadAjaxBehavior); Drupal.ajax.bindAjaxLinks(document.body); once('ajax', '.use-ajax-submit').forEach((el) => { const elementSettings = {}; elementSettings.url = $(el.form).attr('action'); elementSettings.setClick = true; elementSettings.event = 'click'; elementSettings.progress = { type: 'throbber' }; elementSettings.base = el.id; elementSettings.element = el; Drupal.ajax(elementSettings); }); }, detach(context, settings, trigger) { if (trigger === 'unload') Drupal.ajax.expired().forEach((instance) => { Drupal.ajax.instances[instance.instanceIndex] = null; }); } }; Drupal.AjaxError = function (xmlhttp, uri, customMessage) { let statusCode; let statusText; let responseText; if (xmlhttp.status) statusCode = `\n${Drupal.t('An AJAX HTTP error occurred.')}\n${Drupal.t('HTTP Result Code: !status', { '!status': xmlhttp.status })}`; else statusCode = `\n${Drupal.t('An AJAX HTTP request terminated abnormally.')}`; statusCode += `\n${Drupal.t('Debugging information follows.')}`; const pathText = `\n${Drupal.t('Path: !uri', { '!uri': uri })}`; statusText = ''; try { statusText = `\n${Drupal.t('StatusText: !statusText', { '!statusText': xmlhttp.statusText.trim() })}`; } catch (e) { } responseText = ''; try { responseText = `\n${Drupal.t('ResponseText: !responseText', { '!responseText': xmlhttp.responseText.trim() })}`; } catch (e) { } responseText = responseText.replace(/<("[^"]*"|'[^']*'|[^'">])*>/gi, ''); responseText = responseText.replace(/[\n]+\s+/g, '\n'); const readyStateText = xmlhttp.status === 0 ? `\n${Drupal.t('ReadyState: !readyState', { '!readyState': xmlhttp.readyState })}` : ''; customMessage = customMessage ? `\n${Drupal.t('CustomMessage: !customMessage', { '!customMessage': customMessage })}` : ''; this.message = statusCode + pathText + statusText + customMessage + responseText + readyStateText; this.name = 'AjaxError'; if (!Drupal.AjaxError.messages) Drupal.AjaxError.messages = new Drupal.Message(); Drupal.AjaxError.messages.add(Drupal.t("Oops, something went wrong. Check your browser's developer console for more details."), { type: 'error' }); }; Drupal.AjaxError.prototype = new Error(); Drupal.AjaxError.prototype.constructor = Drupal.AjaxError; Drupal.ajax = function (settings) { if (arguments.length !== 1) throw new Error('Drupal.ajax() function must be called with one configuration object only'); const base = settings.base || false; const element = settings.element || false; delete settings.base; delete settings.element; if (!settings.progress && !element) settings.progress = false; const ajax = new Drupal.Ajax(base, element, settings); ajax.instanceIndex = Drupal.ajax.instances.length; Drupal.ajax.instances.push(ajax); return ajax; }; Drupal.ajax.instances = []; Drupal.ajax.expired = function () { return Drupal.ajax.instances.filter((instance) => instance && instance.element !== false && !document.body.contains(instance.element)); }; Drupal.ajax.bindAjaxLinks = (element) => { once('ajax', '.use-ajax', element).forEach((ajaxLink) => { const $linkElement = $(ajaxLink); const elementSettings = { progress: { type: 'throbber' }, dialogType: $linkElement.data('dialog-type'), dialog: $linkElement.data('dialog-options'), dialogRenderer: $linkElement.data('dialog-renderer'), base: $linkElement.attr('id'), element: ajaxLink }; const href = $linkElement.attr('href'); if (href) { elementSettings.url = href; elementSettings.event = 'click'; } const httpMethod = $linkElement.data('ajax-http-method'); if (httpMethod) elementSettings.httpMethod = httpMethod; Drupal.ajax(elementSettings); }); }; Drupal.Ajax = function (base, element, elementSettings) { const defaults = { httpMethod: 'POST', event: element ? 'mousedown' : null, keypress: true, selector: base ? `#${base}` : null, effect: 'none', speed: 'none', method: 'replaceWith', progress: { type: 'throbber', message: Drupal.t('Processing...') }, submit: { js: true } }; $.extend(this, defaults, elementSettings); this.commands = new Drupal.AjaxCommands(); this.instanceIndex = false; if (this.wrapper) this.wrapper = `#${this.wrapper}`; this.element = element; this.preCommandsFocusedElementSelector = null; this.elementSettings = elementSettings; if (this.element && this.element.form) this.$form = $(this.element.form); if (!this.url) { const $element = $(this.element); if (this.element.tagName === 'A') this.url = $element.attr('href'); else { if (this.element && element.form) this.url = this.$form.attr('action'); } } const originalUrl = this.url; this.url = this.url.replace(/\/nojs(\/|$|\?|#)/, '/ajax$1'); if (drupalSettings.ajaxTrustedUrl[originalUrl]) drupalSettings.ajaxTrustedUrl[this.url] = true; const ajax = this; ajax.options = { url: ajax.url, data: ajax.submit, isInProgress() { return ajax.ajaxing; }, beforeSerialize(elementSettings, options) { return ajax.beforeSerialize(elementSettings, options); }, beforeSubmit(formValues, elementSettings, options) { ajax.ajaxing = true; ajax.preCommandsFocusedElementSelector = null; return ajax.beforeSubmit(formValues, elementSettings, options); }, beforeSend(xmlhttprequest, options) { ajax.ajaxing = true; return ajax.beforeSend(xmlhttprequest, options); }, success(response, status, xmlhttprequest) { ajax.preCommandsFocusedElementSelector = document.activeElement.getAttribute('data-drupal-selector'); if (typeof response === 'string') response = $.parseJSON(response); if (response !== null && !drupalSettings.ajaxTrustedUrl[ajax.url]) if (xmlhttprequest.getResponseHeader('X-Drupal-Ajax-Token') !== '1') { const customMessage = Drupal.t('The response failed verification so will not be processed.'); return ajax.error(xmlhttprequest, ajax.url, customMessage); } return (Promise.resolve(ajax.success(response, status)).then(() => { ajax.ajaxing = false; $(document).trigger('ajaxSuccess', [xmlhttprequest, this]); $(document).trigger('ajaxComplete', [xmlhttprequest, this]); if (--$.active === 0) $(document).trigger('ajaxStop'); })); }, error(xmlhttprequest, status, error) { ajax.ajaxing = false; }, complete(xmlhttprequest, status) { if (status === 'error' || status === 'parsererror') return ajax.error(xmlhttprequest, ajax.url); }, dataType: 'json', jsonp: false, method: ajax.httpMethod }; if (elementSettings.dialog) ajax.options.data.dialogOptions = elementSettings.dialog; if (!ajax.options.url.includes('?')) ajax.options.url += '?'; else ajax.options.url += '&'; let wrapper = `drupal_${elementSettings.dialogType || 'ajax'}`; if (elementSettings.dialogRenderer) wrapper += `.${elementSettings.dialogRenderer}`; ajax.options.url += `${Drupal.ajax.WRAPPER_FORMAT}=${wrapper}`; $(ajax.element).on(elementSettings.event, function (event) { if (!drupalSettings.ajaxTrustedUrl[ajax.url] && !Drupal.url.isLocal(ajax.url)) throw new Error(Drupal.t('The callback URL is not local and not trusted: !url', { '!url': ajax.url })); return ajax.eventResponse(this, event); }); if (elementSettings.keypress) $(ajax.element).on('keypress', function (event) { return ajax.keypressResponse(this, event); }); if (elementSettings.prevent) $(ajax.element).on(elementSettings.prevent, false); }; Drupal.ajax.WRAPPER_FORMAT = '_wrapper_format'; Drupal.Ajax.AJAX_REQUEST_PARAMETER = '_drupal_ajax'; Drupal.Ajax.prototype.execute = function () { if (this.ajaxing) return; try { this.beforeSerialize(this.element, this.options); return $.ajax(this.options); } catch (e) { this.ajaxing = false; window.alert(`An error occurred while attempting to process ${this.options.url}: ${e.message}`); return $.Deferred().reject(); } }; Drupal.Ajax.prototype.keypressResponse = function (element, event) { const ajax = this; if (event.which === 13 || (event.which === 32 && element.type !== 'text' && element.type !== 'textarea' && element.type !== 'tel' && element.type !== 'number')) { event.preventDefault(); event.stopPropagation(); $(element).trigger(ajax.elementSettings.event); } }; Drupal.Ajax.prototype.eventResponse = function (element, event) { event.preventDefault(); event.stopPropagation(); const ajax = this; if (ajax.ajaxing) return; try { if (ajax.$form) { if (ajax.setClick) element.form.clk = element; ajax.$form.ajaxSubmit(ajax.options); } else { ajax.beforeSerialize(ajax.element, ajax.options); $.ajax(ajax.options); } } catch (e) { ajax.ajaxing = false; window.alert(`An error occurred while attempting to process ${ajax.options.url}: ${e.message}`); } }; Drupal.Ajax.prototype.beforeSerialize = function (element, options) { if (this.$form && document.body.contains(this.$form.get(0))) { const settings = this.settings || drupalSettings; Drupal.detachBehaviors(this.$form.get(0), settings, 'serialize'); } options.data[Drupal.Ajax.AJAX_REQUEST_PARAMETER] = 1; const pageState = drupalSettings.ajaxPageState; options.data['ajax_page_state[theme]'] = pageState.theme; options.data['ajax_page_state[theme_token]'] = pageState.theme_token; options.data['ajax_page_state[libraries]'] = pageState.libraries; }; Drupal.Ajax.prototype.beforeSubmit = function (formValues, element, options) { }; Drupal.Ajax.prototype.beforeSend = function (xmlhttprequest, options) { if (this.$form) { options.extraData = options.extraData || {}; options.extraData.ajax_iframe_upload = '1'; const v = $.fieldValue(this.element); if (v !== null) options.extraData[this.element.name] = v; } $(this.element).prop('disabled', true); if (!this.progress || !this.progress.type) return; const progressIndicatorMethod = `setProgressIndicator${this.progress.type.slice(0, 1).toUpperCase()}${this.progress.type.slice(1).toLowerCase()}`; if (progressIndicatorMethod in this && typeof this[progressIndicatorMethod] === 'function') this[progressIndicatorMethod].call(this); }; Drupal.theme.ajaxProgressThrobber = (message) => { const messageMarkup = typeof message === 'string' ? Drupal.theme('ajaxProgressMessage', message) : ''; const throbber = '<div class="throbber">&nbsp;</div>'; return `<div class="ajax-progress ajax-progress-throbber">${throbber}${messageMarkup}</div>`; }; Drupal.theme.ajaxProgressIndicatorFullscreen = () => '<div class="ajax-progress ajax-progress-fullscreen">&nbsp;</div>'; Drupal.theme.ajaxProgressMessage = (message) => `<div class="message">${message}</div>`; Drupal.theme.ajaxProgressBar = ($element) => $('<div class="ajax-progress ajax-progress-bar"></div>').append($element); Drupal.Ajax.prototype.setProgressIndicatorBar = function () { const progressBar = new Drupal.ProgressBar(`ajax-progress-${this.element.id}`, $.noop, this.progress.method, $.noop); if (this.progress.message) progressBar.setProgress(-1, this.progress.message); if (this.progress.url) progressBar.startMonitoring(this.progress.url, this.progress.interval || 1500); this.progress.element = $(Drupal.theme('ajaxProgressBar', progressBar.element)); this.progress.object = progressBar; $(this.element).after(this.progress.element); }; Drupal.Ajax.prototype.setProgressIndicatorThrobber = function () { this.progress.element = $(Drupal.theme('ajaxProgressThrobber', this.progress.message)); if ($(this.element).closest('[data-drupal-ajax-container]').length) $(this.element).closest('[data-drupal-ajax-container]').after(this.progress.element); else $(this.element).after(this.progress.element); }; Drupal.Ajax.prototype.setProgressIndicatorFullscreen = function () { this.progress.element = $(Drupal.theme('ajaxProgressIndicatorFullscreen')); $('body').append(this.progress.element); }; Drupal.Ajax.prototype.commandExecutionQueue = function (response, status) { const ajaxCommands = this.commands; return Object.keys(response || {}).reduce((executionQueue, key) => executionQueue.then(() => { const { command } = response[key]; if (command && ajaxCommands[command]) return ajaxCommands[command](this, response[key], status); }), Promise.resolve()); }; Drupal.Ajax.prototype.success = function (response, status) { if (this.progress.element) $(this.progress.element).remove(); if (this.progress.object) this.progress.object.stopMonitoring(); $(this.element).prop('disabled', false); const elementParents = $(this.element).parents('[data-drupal-selector]').addBack().toArray(); const focusChanged = Object.keys(response || {}).some((key) => { const { command, method } = response[key]; return (command === 'focusFirst' || command === 'openDialog' || (command === 'invoke' && method === 'focus')); }); return (this.commandExecutionQueue(response, status).then(() => { if (!focusChanged) { let target = false; if (this.element) { if ($(this.element).data('refocus-blur') && this.preCommandsFocusedElementSelector) target = document.querySelector(`[data-drupal-selector="${this.preCommandsFocusedElementSelector}"]`); if (!target && !$(this.element).data('disable-refocus')) { for (let n = elementParents.length - 1; !target && n >= 0; n--)target = document.querySelector(`[data-drupal-selector="${elementParents[n].getAttribute('data-drupal-selector')}"]`); } } if (target) $(target).trigger('focus'); } if (this.$form && document.body.contains(this.$form.get(0))) { const settings = this.settings || drupalSettings; Drupal.attachBehaviors(this.$form.get(0), settings); } this.settings = null; }).catch((error) => console.error(Drupal.t('An error occurred during the execution of the Ajax response: !error', { '!error': error })))); }; Drupal.Ajax.prototype.getEffect = function (response) { const type = response.effect || this.effect; const speed = response.speed || this.speed; const effect = {}; if (type === 'none') { effect.showEffect = 'show'; effect.hideEffect = 'hide'; effect.showSpeed = ''; } else if (type === 'fade') { effect.showEffect = 'fadeIn'; effect.hideEffect = 'fadeOut'; effect.showSpeed = speed; } else { effect.showEffect = `${type}Toggle`; effect.hideEffect = `${type}Toggle`; effect.showSpeed = speed; } return effect; }; Drupal.Ajax.prototype.error = function (xmlhttprequest, uri, customMessage) { if (this.progress.element) $(this.progress.element).remove(); if (this.progress.object) this.progress.object.stopMonitoring(); $(this.wrapper).show(); $(this.element).prop('disabled', false); if (this.$form && document.body.contains(this.$form.get(0))) { const settings = this.settings || drupalSettings; Drupal.attachBehaviors(this.$form.get(0), settings); } throw new Drupal.AjaxError(xmlhttprequest, uri, customMessage); }; Drupal.theme.ajaxWrapperNewContent = ($newContent, ajax, response) => (response.effect || ajax.effect) !== 'none' && $newContent.filter((i) => !(($newContent[i].nodeName === '#comment' || ($newContent[i].nodeName === '#text' && /^(\s|\n|\r)*$/.test($newContent[i].textContent))))).length > 1 ? Drupal.theme('ajaxWrapperMultipleRootElements', $newContent) : $newContent; Drupal.theme.ajaxWrapperMultipleRootElements = ($elements) => $('<div></div>').append($elements); Drupal.AjaxCommands = function () { }; Drupal.AjaxCommands.prototype = { insert(ajax, response) { const $wrapper = response.selector ? $(response.selector) : $(ajax.wrapper); const method = response.method || ajax.method; const effect = ajax.getEffect(response); const settings = response.settings || ajax.settings || drupalSettings; const parseHTML = (htmlString) => { const fragment = document.createDocumentFragment(); const tempDiv = fragment.appendChild(document.createElement('div')); tempDiv.innerHTML = htmlString; return tempDiv.childNodes; }; let $newContent = $(parseHTML(response.data)); $newContent = Drupal.theme('ajaxWrapperNewContent', $newContent, ajax, response); switch (method) { case 'html': case 'replaceWith': case 'replaceAll': case 'empty': case 'remove': Drupal.detachBehaviors($wrapper.get(0), settings); break; default: break; }$wrapper[method]($newContent); if (effect.showEffect !== 'show') $newContent.hide(); const $ajaxNewContent = $newContent.find('.ajax-new-content'); if ($ajaxNewContent.length) { $ajaxNewContent.hide(); $newContent.show(); $ajaxNewContent[effect.showEffect](effect.showSpeed); } else { if (effect.showEffect !== 'show') $newContent[effect.showEffect](effect.showSpeed); } $newContent.each((index, element) => { if (element.nodeType === Node.ELEMENT_NODE && document.documentElement.contains(element)) Drupal.attachBehaviors(element, settings); }); }, remove(ajax, response, status) { const settings = response.settings || ajax.settings || drupalSettings; $(response.selector).each(function () { Drupal.detachBehaviors(this, settings); }).remove(); }, changed(ajax, response, status) { const $element = $(response.selector); if (!$element.hasClass('ajax-changed')) { $element.addClass('ajax-changed'); if (response.asterisk) $element.find(response.asterisk).append(` <abbr class="ajax-changed" title="${Drupal.t('Changed')}">*</abbr> `); } }, alert(ajax, response, status) { window.alert(response.text); }, announce(ajax, response) { if (response.priority) Drupal.announce(response.text, response.priority); else Drupal.announce(response.text); }, redirect(ajax, response, status) { window.location = response.url; }, css(ajax, response, status) { $(response.selector).css(response.argument); }, settings(ajax, response, status) { const ajaxSettings = drupalSettings.ajax; if (ajaxSettings) Drupal.ajax.expired().forEach((instance) => { if (instance.selector) { const selector = instance.selector.replace('#', ''); if (selector in ajaxSettings) delete ajaxSettings[selector]; } }); if (response.merge) $.extend(true, drupalSettings, response.settings); else ajax.settings = response.settings; }, data(ajax, response, status) { $(response.selector).data(response.name, response.value); }, focusFirst(ajax, response, status) { let focusChanged = false; const container = document.querySelector(response.selector); if (container) { const tabbableElements = tabbable(container); if (tabbableElements.length) { tabbableElements[0].focus(); focusChanged = true; } else { if (isFocusable(container)) { container.focus(); focusChanged = true; } } } if (ajax.hasOwnProperty('element') && !focusChanged) ajax.element.focus(); }, invoke(ajax, response, status) { const $element = $(response.selector); $element[response.method](...response.args); }, restripe(ajax, response, status) { $(response.selector).find('> tbody > tr:visible, > tr:visible').removeClass('odd even').filter(':even').addClass('odd').end().filter(':odd').addClass('even'); }, update_build_id(ajax, response, status) { document.querySelectorAll(`input[name="form_build_id"][value="${response.old}"]`).forEach((item) => { item.value = response.new; }); }, add_css(ajax, response, status) { if (typeof response.data === 'string') { Drupal.deprecationError({ message: 'Passing a string to the Drupal.ajax.add_css() method is deprecated in 10.1.0 and is removed from drupal:11.0.0. See https://www.drupal.org/node/3154948.' }); $('head').prepend(response.data); return; } const allUniqueBundleIds = response.data.map(function (style) { const uniqueBundleId = style.href; if (!loadjs.isDefined(uniqueBundleId)) loadjs(`css!${style.href}`, uniqueBundleId, { before(path, styleEl) { Object.keys(style).forEach((attributeKey) => { styleEl.setAttribute(attributeKey, style[attributeKey]); }); } }); return uniqueBundleId; }); return new Promise((resolve, reject) => { loadjs.ready(allUniqueBundleIds, { success() { resolve(); }, error(depsNotFound) { const message = Drupal.t(`The following files could not be loaded: @dependencies`, { '@dependencies': depsNotFound.join(', ') }); reject(message); } }); }); }, message(ajax, response) { const messages = new Drupal.Message(document.querySelector(response.messageWrapperQuerySelector)); if (response.clearPrevious) messages.clear(); messages.add(response.message, response.messageOptions); }, add_js(ajax, response, status) { const parentEl = document.querySelector(response.selector || 'body'); const settings = ajax.settings || drupalSettings; const allUniqueBundleIds = response.data.map((script) => { const uniqueBundleId = script.src; if (!loadjs.isDefined(uniqueBundleId)) loadjs(script.src, uniqueBundleId, { async: false, before(path, scriptEl) { Object.keys(script).forEach((attributeKey) => { scriptEl.setAttribute(attributeKey, script[attributeKey]); }); parentEl.appendChild(scriptEl); return false; } }); return uniqueBundleId; }); return new Promise((resolve, reject) => { loadjs.ready(allUniqueBundleIds, { success() { Drupal.attachBehaviors(parentEl, settings); resolve(); }, error(depsNotFound) { const message = Drupal.t(`The following files could not be loaded: @dependencies`, { '@dependencies': depsNotFound.join(', ') }); reject(message); } }); }); }, scrollTop(ajax, response) { const offset = $(response.selector).offset(); let scrollTarget = response.selector; while ($(scrollTarget).scrollTop() === 0 && $(scrollTarget).parent()) scrollTarget = $(scrollTarget).parent(); if (offset.top - 10 < $(scrollTarget).scrollTop()) scrollTarget.get(0).scrollTo({ top: offset.top - 10, behavior: 'smooth' }); } }; const stopEvent = (xhr, settings) => { return (xhr.getResponseHeader('X-Drupal-Ajax-Token') === '1' && settings.isInProgress && settings.isInProgress()); }; $.extend(true, $.event.special, { ajaxSuccess: { trigger(event, xhr, settings) { if (stopEvent(xhr, settings)) return false; } }, ajaxComplete: { trigger(event, xhr, settings) { if (stopEvent(xhr, settings)) { $.active++; return false; } } } }); })(jQuery, window, Drupal, drupalSettings, loadjs, window.tabbable);;
"use strict"; (function (a, b, c) { var d = function (a) { return window.matchMedia("(min-width: 992px)").matches ? a ? 56 : 40 : 40; }, e = function (a) { a && a.length && a.forEach(function (a) { var b = .5 * a.offsetHeight; a.style.transform = "translateY(-".concat(b, "px)"), a.style.marginBottom = "-".concat(b, "px"); var c = a.previousElementSibling && a.previousElementSibling.classList.contains("layout") ? a.previousElementSibling : null; c && (c.style.paddingBottom = "".concat(b + d(!0), "px")); var e = a.nextElementSibling && a.nextElementSibling.classList.contains("layout") ? a.nextElementSibling : null; if (e) { var f = b + d(); e.style.paddingTop = "".concat(f, "px"), e.style.marginBottom = "-".concat(b, "px"), e.style.transform = "translateY(-".concat(b, "px)"); } }); }; a.behaviors.floatingSection = { attach: function (b) { var d = c("floatingLayoutInit", ".lbs-section-disease-block", b); d && d.length && (window.addEventListener("DOMContentLoaded", function () { return e(d); }), window.addEventListener("resize", function () { return a.debounce(e(d), 450); })); } }, a.behaviors.ovelayedBanner = { attach: function (a) { var b = c("overlayedBannerInit", "[data-drupal-selector=\"hero-banner\"]", a); if (b.length && b[0].classList.contains("hero-banner--one-col")) { var d = document.querySelector("[data-drupal-selector=\"header-main\"]"), e = document.querySelector(".landing-page__content > .layout:first-of-type  [data-drupal-selector=\"grid-cta\"]"), f = document.querySelectorAll(".layout-builder-form").length, g = document.querySelector(".landing-page__content .layout:first-of-type .hero-banner--one-col") || document.querySelector(".node__content > .hero-banner--one-col"); if (d && !f && g && d.classList.add("overlayed-header"), e) { e.classList.add("grid-cta--overlayed"); var h = e.closest(".layout"); h && (h.style.height = "0"); } } } }, a.behaviors.sidebarWithContent = { attach: function (a) { c("sidebar-with-content-set-height", "[data-drupal-selector=\"sidebar-with-content\"]", a).forEach(function (a) { var b = a.querySelector(".site-aside"); if (b && 992 <= window.innerWidth) { var c = b.offsetHeight; a.style.minHeight = "".concat(c + 24, "px"); } }), c("dialog-observe", "body", a).forEach(function (a) { var c = new MutationObserver(function (c) { c.some(function (a) { return a.target.classList.contains("get-started-form-modal"); }) && (b(".get-started-form-modal").length ? b(a).append("<div class=\"ui-widget-overlay ui-front\" style=\"z-index: 100;\"></div>") : b(".ui-widget-overlay").remove()); }); c.observe(document.body, { childList: !0, subtree: !0 }); }); } }, a.behaviors.regionalMenu = { attach: function (a) { var b = c("regionalSitesInit", "[data-drupal-selector=\"menu-main\"]", a); if (b.length) { var d = document.body.getAttribute("data-region") && "main site" !== document.body.getAttribute("data-region") ? document.body.getAttribute("data-region") : "main", e = b[0].querySelectorAll(".regional-item"); if (e.length) { e.forEach(function (a) { a.classList.add("hide"), "main" === d && a.classList.contains("show-main") && a.classList.remove("hide"); var b = a.getAttribute("data-attr"); if (b) { var c = a.closest(".menu-level-1__wrapper").querySelector(".menu-level-1__content .menu-inner-content[data-attr='".concat(b, "']")); c && c.classList.add("hide"); } }); var f = b[0].querySelectorAll(".regional-item.show-".concat(d)); f.length && f.forEach(function (a) { a.classList.remove("hide"); var b = a.getAttribute("data-attr"); if (b) { var c = a.closest(".menu-level-1__wrapper").querySelector(".menu-level-1__content .menu-inner-content[data-attr='".concat(b, "']")); c && (c.classList.remove("hide"), c.classList.add("hospital-active")); } }); } } } }, a.behaviors.requestCallbackGlobalBlock = { attach: function (a) { a === document && (document.addEventListener("click", function (a) { var c = a.target, d = c.closest("a"); if (d && "A" === d.tagName) { var e = d.getAttribute("href"); if (e && e.includes("/openForm#")) { a.preventDefault(); var f = document.querySelector(".request-callback-form"); if (f) { var g = e.split("#")[1], h = f.querySelectorAll(".form-item__request-type input.request-type-field"); if (g && h.length) { var i = f.querySelector(".form-item__request-type input.request-type-field:checked"); switch (i && i.removeAttribute("checked"), g) { case "book2": h[1].setAttribute("checked", "checked"); break; case "book3": h[2].setAttribute("checked", "checked"); break; default: h[0].setAttribute("checked", "checked"); } } if (d.classList.contains("request-doctor-card")) { var j = d.closest(".doctor-card"); if (j) { var k = f.querySelector("fieldset.request-type-field"); if (k) { k.style.display = "none"; var l = f.querySelector(".title-text"); l && (l.style.margin = "0 0 10px"); } var m = j.getAttribute("id").split("-")[1], n = j.getAttribute("data-specialityid").split("-")[1], o = j.getAttribute("data-cityid").split("-")[1], p = f.querySelector("#docid-form-container"), q = f.querySelector("#specid-form-container"), r = f.querySelector("#edit-city"); p && m.length && p.setAttribute("value", "".concat(m)), q && n.length && q.setAttribute("value", "".concat(n)), r && o.length && b(r).val(o).trigger("change"); } } f.style.display = "block"; } } else { var s = document.querySelector(".request-callback-form"); s && (s.style.display = "none"); } } if (c.closest(".ui-dialog-titlebar-close")) { var t = c.closest(".ui-dialog-titlebar-close"); if (t) { var u = document.querySelector(".request-callback-form"); u && (u.style.display = "none"); } } }), setTimeout(function () { var a = document.querySelector(".node-landing-page-layout-builder-form"); if (a) { var b = document.querySelector(".request-callback-form"); b && (b.style.display = "none"); } }, 3e3)); } }, a.behaviors.investorTabs = { attach: function (a) { c("investor-relations", ".lbs-investor-relations-tabs .text-card .text-card__body", a).forEach(function (a) { var b = a.querySelectorAll("ul li a"); b.forEach(function (a) { a.addEventListener("click", function (b) { b.preventDefault(); var c = a.getAttribute("href"); document.querySelector(c).scrollIntoView({ behavior: "smooth" }); }); }); }); } }; })(Drupal, window.jQuery, once);;
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("@popperjs/core")) : "function" == typeof define && define.amd ? define(["@popperjs/core"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e(t.Popper) }(this, (function (t) { "use strict"; function e(t) { const e = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } }); if (t) for (const i in t) if ("default" !== i) { const s = Object.getOwnPropertyDescriptor(t, i); Object.defineProperty(e, i, s.get ? s : { enumerable: !0, get: () => t[i] }) } return e.default = t, Object.freeze(e) } const i = e(t), s = new Map, n = { set(t, e, i) { s.has(t) || s.set(t, new Map); const n = s.get(t); n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`) }, get: (t, e) => s.has(t) && s.get(t).get(e) || null, remove(t, e) { if (!s.has(t)) return; const i = s.get(t); i.delete(e), 0 === i.size && s.delete(t) } }, o = "transitionend", r = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t), a = t => { t.dispatchEvent(new Event(o)) }, l = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), c = t => l(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(r(t)) : null, h = t => { if (!l(t) || 0 === t.getClientRects().length) return !1; const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"), i = t.closest("details:not([open])"); if (!i) return e; if (i !== t) { const e = t.closest("summary"); if (e && e.parentNode !== i) return !1; if (null === e) return !1 } return e }, d = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), u = t => { if (!document.documentElement.attachShadow) return null; if ("function" == typeof t.getRootNode) { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } return t instanceof ShadowRoot ? t : t.parentNode ? u(t.parentNode) : null }, _ = () => { }, g = t => { t.offsetHeight }, f = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, m = [], p = () => "rtl" === document.documentElement.dir, b = t => { var e; e = () => { const e = f(); if (e) { const i = t.NAME, s = e.fn[i]; e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = s, t.jQueryInterface) } }, "loading" === document.readyState ? (m.length || document.addEventListener("DOMContentLoaded", (() => { for (const t of m) t() })), m.push(e)) : e() }, v = (t, e = [], i = t) => "function" == typeof t ? t(...e) : i, y = (t, e, i = !0) => { if (!i) return void v(t); const s = (t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: i } = window.getComputedStyle(t); const s = Number.parseFloat(e), n = Number.parseFloat(i); return s || n ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0 })(e) + 5; let n = !1; const r = ({ target: i }) => { i === e && (n = !0, e.removeEventListener(o, r), v(t)) }; e.addEventListener(o, r), setTimeout((() => { n || a(e) }), s) }, w = (t, e, i, s) => { const n = t.length; let o = t.indexOf(e); return -1 === o ? !i && s ? t[n - 1] : t[0] : (o += i ? 1 : -1, s && (o = (o + n) % n), t[Math.max(0, Math.min(o, n - 1))]) }, A = /[^.]*(?=\..*)\.|.*/, E = /\..*/, C = /::\d+$/, T = {}; let k = 1; const $ = { mouseenter: "mouseover", mouseleave: "mouseout" }, S = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function L(t, e) { return e && `${e}::${k++}` || t.uidEvent || k++ } function O(t) { const e = L(t); return t.uidEvent = e, T[e] = T[e] || {}, T[e] } function I(t, e, i = null) { return Object.values(t).find((t => t.callable === e && t.delegationSelector === i)) } function D(t, e, i) { const s = "string" == typeof e, n = s ? i : e || i; let o = M(t); return S.has(o) || (o = t), [s, n, o] } function N(t, e, i, s, n) { if ("string" != typeof e || !t) return; let [o, r, a] = D(e, i, s); if (e in $) { const t = t => function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e) }; r = t(r) } const l = O(t), c = l[a] || (l[a] = {}), h = I(c, r, o ? i : null); if (h) return void (h.oneOff = h.oneOff && n); const d = L(r, e.replace(A, "")), u = o ? function (t, e, i) { return function s(n) { const o = t.querySelectorAll(e); for (let { target: r } = n; r && r !== this; r = r.parentNode)for (const a of o) if (a === r) return F(n, { delegateTarget: r }), s.oneOff && j.off(t, n.type, e, i), i.apply(r, [n]) } }(t, i, r) : function (t, e) { return function i(s) { return F(s, { delegateTarget: t }), i.oneOff && j.off(t, s.type, e), e.apply(t, [s]) } }(t, r); u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = n, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o) } function P(t, e, i, s, n) { const o = I(e[i], s, n); o && (t.removeEventListener(i, o, Boolean(n)), delete e[i][o.uidEvent]) } function x(t, e, i, s) { const n = e[i] || {}; for (const [o, r] of Object.entries(n)) o.includes(s) && P(t, e, i, r.callable, r.delegationSelector) } function M(t) { return t = t.replace(E, ""), $[t] || t } const j = { on(t, e, i, s) { N(t, e, i, s, !1) }, one(t, e, i, s) { N(t, e, i, s, !0) }, off(t, e, i, s) { if ("string" != typeof e || !t) return; const [n, o, r] = D(e, i, s), a = r !== e, l = O(t), c = l[r] || {}, h = e.startsWith("."); if (void 0 === o) { if (h) for (const i of Object.keys(l)) x(t, l, i, e.slice(1)); for (const [i, s] of Object.entries(c)) { const n = i.replace(C, ""); a && !e.includes(n) || P(t, l, r, s.callable, s.delegationSelector) } } else { if (!Object.keys(c).length) return; P(t, l, r, o, n ? i : null) } }, trigger(t, e, i) { if ("string" != typeof e || !t) return null; const s = f(); let n = null, o = !0, r = !0, a = !1; e !== M(e) && s && (n = s.Event(e, i), s(t).trigger(n), o = !n.isPropagationStopped(), r = !n.isImmediatePropagationStopped(), a = n.isDefaultPrevented()); const l = F(new Event(e, { bubbles: o, cancelable: !0 }), i); return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && n && n.preventDefault(), l } }; function F(t, e = {}) { for (const [i, s] of Object.entries(e)) try { t[i] = s } catch (e) { Object.defineProperty(t, i, { configurable: !0, get: () => s }) } return t } function z(t) { if ("true" === t) return !0; if ("false" === t) return !1; if (t === Number(t).toString()) return Number(t); if ("" === t || "null" === t) return null; if ("string" != typeof t) return t; try { return JSON.parse(decodeURIComponent(t)) } catch (e) { return t } } function H(t) { return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`)) } const B = { setDataAttribute(t, e, i) { t.setAttribute(`data-bs-${H(e)}`, i) }, removeDataAttribute(t, e) { t.removeAttribute(`data-bs-${H(e)}`) }, getDataAttributes(t) { if (!t) return {}; const e = {}, i = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig"))); for (const s of i) { let i = s.replace(/^bs/, ""); i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = z(t.dataset[s]) } return e }, getDataAttribute: (t, e) => z(t.getAttribute(`data-bs-${H(e)}`)) }; class q { static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } _getConfig(t) { return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } _configAfterMerge(t) { return t } _mergeConfigObj(t, e) { const i = l(e) ? B.getDataAttribute(e, "config") : {}; return { ...this.constructor.Default, ..."object" == typeof i ? i : {}, ...l(e) ? B.getDataAttributes(e) : {}, ..."object" == typeof t ? t : {} } } _typeCheckConfig(t, e = this.constructor.DefaultType) { for (const [s, n] of Object.entries(e)) { const e = t[s], o = l(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`) } var i } } class W extends q { constructor(t, e) { super(), (t = c(t)) && (this._element = t, this._config = this._getConfig(e), n.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { n.remove(this._element, this.constructor.DATA_KEY), j.off(this._element, this.constructor.EVENT_KEY); for (const t of Object.getOwnPropertyNames(this)) this[t] = null } _queueCallback(t, e, i = !0) { y(t, e, i) } _getConfig(t) { return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } static getInstance(t) { return n.get(c(t), this.DATA_KEY) } static getOrCreateInstance(t, e = {}) { return this.getInstance(t) || new this(t, "object" == typeof e ? e : null) } static get VERSION() { return "5.3.3" } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(t) { return `${t}${this.EVENT_KEY}` } } const R = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let i = t.getAttribute("href"); if (!i || !i.includes("#") && !i.startsWith(".")) return null; i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null } return e ? e.split(",").map((t => r(t))).join(",") : null }, K = { find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)), findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t), children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))), parents(t, e) { const i = []; let s = t.parentNode.closest(e); for (; s;)i.push(s), s = s.parentNode.closest(e); return i }, prev(t, e) { let i = t.previousElementSibling; for (; i;) { if (i.matches(e)) return [i]; i = i.previousElementSibling } return [] }, next(t, e) { let i = t.nextElementSibling; for (; i;) { if (i.matches(e)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren(t) { const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(","); return this.find(e, t).filter((t => !d(t) && h(t))) }, getSelectorFromElement(t) { const e = R(t); return e && K.findOne(e) ? e : null }, getElementFromSelector(t) { const e = R(t); return e ? K.findOne(e) : null }, getMultipleElementsFromSelector(t) { const e = R(t); return e ? K.find(e) : [] } }, V = (t, e = "hide") => { const i = `click.dismiss${t.EVENT_KEY}`, s = t.NAME; j.on(document, i, `[data-bs-dismiss="${s}"]`, (function (i) { if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), d(this)) return; const n = K.getElementFromSelector(this) || this.closest(`.${s}`); t.getOrCreateInstance(n)[e]() })) }, Q = ".bs.alert", X = `close${Q}`, Y = `closed${Q}`; class U extends W { static get NAME() { return "alert" } close() { if (j.trigger(this._element, X).defaultPrevented) return; this._element.classList.remove("show"); const t = this._element.classList.contains("fade"); this._queueCallback((() => this._destroyElement()), this._element, t) } _destroyElement() { this._element.remove(), j.trigger(this._element, Y), this.dispose() } static jQueryInterface(t) { return this.each((function () { const e = U.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } V(U, "close"), b(U); const G = '[data-bs-toggle="button"]'; class J extends W { static get NAME() { return "button" } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")) } static jQueryInterface(t) { return this.each((function () { const e = J.getOrCreateInstance(this); "toggle" === t && e[t]() })) } } j.on(document, "click.bs.button.data-api", G, (t => { t.preventDefault(); const e = t.target.closest(G); J.getOrCreateInstance(e).toggle() })), b(J); const Z = ".bs.swipe", tt = `touchstart${Z}`, et = `touchmove${Z}`, it = `touchend${Z}`, st = `pointerdown${Z}`, nt = `pointerup${Z}`, ot = { endCallback: null, leftCallback: null, rightCallback: null }, rt = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }; class at extends q { constructor(t, e) { super(), this._element = t, t && at.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()) } static get Default() { return ot } static get DefaultType() { return rt } static get NAME() { return "swipe" } dispose() { j.off(this._element, Z) } _start(t) { this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX } _end(t) { this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), v(this._config.endCallback) } _move(t) { this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX } _handleSwipe() { const t = Math.abs(this._deltaX); if (t <= 40) return; const e = t / this._deltaX; this._deltaX = 0, e && v(e > 0 ? this._config.rightCallback : this._config.leftCallback) } _initEvents() { this._supportPointerEvents ? (j.on(this._element, st, (t => this._start(t))), j.on(this._element, nt, (t => this._end(t))), this._element.classList.add("pointer-event")) : (j.on(this._element, tt, (t => this._start(t))), j.on(this._element, et, (t => this._move(t))), j.on(this._element, it, (t => this._end(t)))) } _eventIsPointerPenTouch(t) { return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType) } static isSupported() { return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 } } const lt = ".bs.carousel", ct = ".data-api", ht = "next", dt = "prev", ut = "left", _t = "right", gt = `slide${lt}`, ft = `slid${lt}`, mt = `keydown${lt}`, pt = `mouseenter${lt}`, bt = `mouseleave${lt}`, vt = `dragstart${lt}`, yt = `load${lt}${ct}`, wt = `click${lt}${ct}`, At = "carousel", Et = "active", Ct = ".active", Tt = ".carousel-item", kt = Ct + Tt, $t = { ArrowLeft: _t, ArrowRight: ut }, St = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, Lt = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" }; class Ot extends W { constructor(t, e) { super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = K.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === At && this.cycle() } static get Default() { return St } static get DefaultType() { return Lt } static get NAME() { return "carousel" } next() { this._slide(ht) } nextWhenVisible() { !document.hidden && h(this._element) && this.next() } prev() { this._slide(dt) } pause() { this._isSliding && a(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval) } _maybeEnableCycle() { this._config.ride && (this._isSliding ? j.one(this._element, ft, (() => this.cycle())) : this.cycle()) } to(t) { const e = this._getItems(); if (t > e.length - 1 || t < 0) return; if (this._isSliding) return void j.one(this._element, ft, (() => this.to(t))); const i = this._getItemIndex(this._getActive()); if (i === t) return; const s = t > i ? ht : dt; this._slide(s, e[t]) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(t) { return t.defaultInterval = t.interval, t } _addEventListeners() { this._config.keyboard && j.on(this._element, mt, (t => this._keydown(t))), "hover" === this._config.pause && (j.on(this._element, pt, (() => this.pause())), j.on(this._element, bt, (() => this._maybeEnableCycle()))), this._config.touch && at.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (const t of K.find(".carousel-item img", this._element)) j.on(t, vt, (t => t.preventDefault())); const t = { leftCallback: () => this._slide(this._directionToOrder(ut)), rightCallback: () => this._slide(this._directionToOrder(_t)), endCallback: () => { "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval)) } }; this._swipeHelper = new at(this._element, t) } _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const e = $t[t.key]; e && (t.preventDefault(), this._slide(this._directionToOrder(e))) } _getItemIndex(t) { return this._getItems().indexOf(t) } _setActiveIndicatorElement(t) { if (!this._indicatorsElement) return; const e = K.findOne(Ct, this._indicatorsElement); e.classList.remove(Et), e.removeAttribute("aria-current"); const i = K.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement); i && (i.classList.add(Et), i.setAttribute("aria-current", "true")) } _updateInterval() { const t = this._activeElement || this._getActive(); if (!t) return; const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10); this._config.interval = e || this._config.defaultInterval } _slide(t, e = null) { if (this._isSliding) return; const i = this._getActive(), s = t === ht, n = e || w(this._getItems(), i, s, this._config.wrap); if (n === i) return; const o = this._getItemIndex(n), r = e => j.trigger(this._element, e, { relatedTarget: n, direction: this._orderToDirection(t), from: this._getItemIndex(i), to: o }); if (r(gt).defaultPrevented) return; if (!i || !n) return; const a = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = n; const l = s ? "carousel-item-start" : "carousel-item-end", c = s ? "carousel-item-next" : "carousel-item-prev"; n.classList.add(c), g(n), i.classList.add(l), n.classList.add(l), this._queueCallback((() => { n.classList.remove(l, c), n.classList.add(Et), i.classList.remove(Et, c, l), this._isSliding = !1, r(ft) }), i, this._isAnimated()), a && this.cycle() } _isAnimated() { return this._element.classList.contains("slide") } _getActive() { return K.findOne(kt, this._element) } _getItems() { return K.find(Tt, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(t) { return p() ? t === ut ? dt : ht : t === ut ? ht : dt } _orderToDirection(t) { return p() ? t === dt ? ut : _t : t === dt ? _t : ut } static jQueryInterface(t) { return this.each((function () { const e = Ot.getOrCreateInstance(this, t); if ("number" != typeof t) { if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } } else e.to(t) })) } } j.on(document, wt, "[data-bs-slide], [data-bs-slide-to]", (function (t) { const e = K.getElementFromSelector(this); if (!e || !e.classList.contains(At)) return; t.preventDefault(); const i = Ot.getOrCreateInstance(e), s = this.getAttribute("data-bs-slide-to"); return s ? (i.to(s), void i._maybeEnableCycle()) : "next" === B.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle()) })), j.on(window, yt, (() => { const t = K.find('[data-bs-ride="carousel"]'); for (const e of t) Ot.getOrCreateInstance(e) })), b(Ot); const It = ".bs.collapse", Dt = `show${It}`, Nt = `shown${It}`, Pt = `hide${It}`, xt = `hidden${It}`, Mt = `click${It}.data-api`, jt = "show", Ft = "collapse", zt = "collapsing", Ht = `:scope .${Ft} .${Ft}`, Bt = '[data-bs-toggle="collapse"]', qt = { parent: null, toggle: !0 }, Wt = { parent: "(null|element)", toggle: "boolean" }; class Rt extends W { constructor(t, e) { super(t, e), this._isTransitioning = !1, this._triggerArray = []; const i = K.find(Bt); for (const t of i) { const e = K.getSelectorFromElement(t), i = K.find(e).filter((t => t === this._element)); null !== e && i.length && this._triggerArray.push(t) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return qt } static get DefaultType() { return Wt } static get NAME() { return "collapse" } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let t = []; if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => Rt.getOrCreateInstance(t, { toggle: !1 })))), t.length && t[0]._isTransitioning) return; if (j.trigger(this._element, Dt).defaultPrevented) return; for (const e of t) e.hide(); const e = this._getDimension(); this._element.classList.remove(Ft), this._element.classList.add(zt), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = `scroll${e[0].toUpperCase() + e.slice(1)}`; this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(zt), this._element.classList.add(Ft, jt), this._element.style[e] = "", j.trigger(this._element, Nt) }), this._element, !0), this._element.style[e] = `${this._element[i]}px` } hide() { if (this._isTransitioning || !this._isShown()) return; if (j.trigger(this._element, Pt).defaultPrevented) return; const t = this._getDimension(); this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, g(this._element), this._element.classList.add(zt), this._element.classList.remove(Ft, jt); for (const t of this._triggerArray) { const e = K.getElementFromSelector(t); e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1) } this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(zt), this._element.classList.add(Ft), j.trigger(this._element, xt) }), this._element, !0) } _isShown(t = this._element) { return t.classList.contains(jt) } _configAfterMerge(t) { return t.toggle = Boolean(t.toggle), t.parent = c(t.parent), t } _getDimension() { return this._element.classList.contains("collapse-horizontal") ? "width" : "height" } _initializeChildren() { if (!this._config.parent) return; const t = this._getFirstLevelChildren(Bt); for (const e of t) { const t = K.getElementFromSelector(e); t && this._addAriaAndCollapsedClass([e], this._isShown(t)) } } _getFirstLevelChildren(t) { const e = K.find(Ht, this._config.parent); return K.find(t, this._config.parent).filter((t => !e.includes(t))) } _addAriaAndCollapsedClass(t, e) { if (t.length) for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e) } static jQueryInterface(t) { const e = {}; return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each((function () { const i = Rt.getOrCreateInstance(this, e); if ("string" == typeof t) { if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`); i[t]() } })) } } j.on(document, Mt, Bt, (function (t) { ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault(); for (const t of K.getMultipleElementsFromSelector(this)) Rt.getOrCreateInstance(t, { toggle: !1 }).toggle() })), b(Rt); const Kt = "dropdown", Vt = ".bs.dropdown", Qt = ".data-api", Xt = "ArrowUp", Yt = "ArrowDown", Ut = `hide${Vt}`, Gt = `hidden${Vt}`, Jt = `show${Vt}`, Zt = `shown${Vt}`, te = `click${Vt}${Qt}`, ee = `keydown${Vt}${Qt}`, ie = `keyup${Vt}${Qt}`, se = "show", ne = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', oe = `${ne}.${se}`, re = ".dropdown-menu", ae = p() ? "top-end" : "top-start", le = p() ? "top-start" : "top-end", ce = p() ? "bottom-end" : "bottom-start", he = p() ? "bottom-start" : "bottom-end", de = p() ? "left-start" : "right-start", ue = p() ? "right-start" : "left-start", _e = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, ge = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" }; class fe extends W { constructor(t, e) { super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = K.next(this._element, re)[0] || K.prev(this._element, re)[0] || K.findOne(re, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return _e } static get DefaultType() { return ge } static get NAME() { return Kt } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (d(this._element) || this._isShown()) return; const t = { relatedTarget: this._element }; if (!j.trigger(this._element, Jt, t).defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children)) j.on(t, "mouseover", _); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(se), this._element.classList.add(se), j.trigger(this._element, Zt, t) } } hide() { if (d(this._element) || !this._isShown()) return; const t = { relatedTarget: this._element }; this._completeHide(t) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(t) { if (!j.trigger(this._element, Ut, t).defaultPrevented) { if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) j.off(t, "mouseover", _); this._popper && this._popper.destroy(), this._menu.classList.remove(se), this._element.classList.remove(se), this._element.setAttribute("aria-expanded", "false"), B.removeDataAttribute(this._menu, "popper"), j.trigger(this._element, Gt, t) } } _getConfig(t) { if ("object" == typeof (t = super._getConfig(t)).reference && !l(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Kt.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t } _createPopper() { if (void 0 === i) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; "parent" === this._config.reference ? t = this._parent : l(this._config.reference) ? t = c(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference); const e = this._getPopperConfig(); this._popper = i.createPopper(t, this._menu, e) } _isShown() { return this._menu.classList.contains(se) } _getPlacement() { const t = this._parent; if (t.classList.contains("dropend")) return de; if (t.classList.contains("dropstart")) return ue; if (t.classList.contains("dropup-center")) return "top"; if (t.classList.contains("dropdown-center")) return "bottom"; const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return t.classList.contains("dropup") ? e ? le : ae : e ? he : ce } _detectNavbar() { return null !== this._element.closest(".navbar") } _getOffset() { const { offset: t } = this._config; return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t } _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return (this._inNavbar || "static" === this._config.display) && (B.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...t, ...v(this._config.popperConfig, [t]) } } _selectMenuItem({ key: t, target: e }) { const i = K.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t => h(t))); i.length && w(i, e, t === Yt, !i.includes(e)).focus() } static jQueryInterface(t) { return this.each((function () { const e = fe.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } static clearMenus(t) { if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return; const e = K.find(oe); for (const i of e) { const e = fe.getInstance(i); if (!e || !1 === e._config.autoClose) continue; const s = t.composedPath(), n = s.includes(e._menu); if (s.includes(e._element) || "inside" === e._config.autoClose && !n || "outside" === e._config.autoClose && n) continue; if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; const o = { relatedTarget: e._element }; "click" === t.type && (o.clickEvent = t), e._completeHide(o) } } static dataApiKeydownHandler(t) { const e = /input|textarea/i.test(t.target.tagName), i = "Escape" === t.key, s = [Xt, Yt].includes(t.key); if (!s && !i) return; if (e && !i) return; t.preventDefault(); const n = this.matches(ne) ? this : K.prev(this, ne)[0] || K.next(this, ne)[0] || K.findOne(ne, t.delegateTarget.parentNode), o = fe.getOrCreateInstance(n); if (s) return t.stopPropagation(), o.show(), void o._selectMenuItem(t); o._isShown() && (t.stopPropagation(), o.hide(), n.focus()) } } j.on(document, ee, ne, fe.dataApiKeydownHandler), j.on(document, ee, re, fe.dataApiKeydownHandler), j.on(document, te, fe.clearMenus), j.on(document, ie, fe.clearMenus), j.on(document, te, ne, (function (t) { t.preventDefault(), fe.getOrCreateInstance(this).toggle() })), b(fe); const me = "backdrop", pe = "show", be = `mousedown.bs.${me}`, ve = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" }, ye = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }; class we extends q { constructor(t) { super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null } static get Default() { return ve } static get DefaultType() { return ye } static get NAME() { return me } show(t) { if (!this._config.isVisible) return void v(t); this._append(); const e = this._getElement(); this._config.isAnimated && g(e), e.classList.add(pe), this._emulateAnimation((() => { v(t) })) } hide(t) { this._config.isVisible ? (this._getElement().classList.remove(pe), this._emulateAnimation((() => { this.dispose(), v(t) }))) : v(t) } dispose() { this._isAppended && (j.off(this._element, be), this._element.remove(), this._isAppended = !1) } _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t } return this._element } _configAfterMerge(t) { return t.rootElement = c(t.rootElement), t } _append() { if (this._isAppended) return; const t = this._getElement(); this._config.rootElement.append(t), j.on(t, be, (() => { v(this._config.clickCallback) })), this._isAppended = !0 } _emulateAnimation(t) { y(t, this._getElement(), this._config.isAnimated) } } const Ae = ".bs.focustrap", Ee = `focusin${Ae}`, Ce = `keydown.tab${Ae}`, Te = "backward", ke = { autofocus: !0, trapElement: null }, $e = { autofocus: "boolean", trapElement: "element" }; class Se extends q { constructor(t) { super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return ke } static get DefaultType() { return $e } static get NAME() { return "focustrap" } activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), j.off(document, Ae), j.on(document, Ee, (t => this._handleFocusin(t))), j.on(document, Ce, (t => this._handleKeydown(t))), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, j.off(document, Ae)) } _handleFocusin(t) { const { trapElement: e } = this._config; if (t.target === document || t.target === e || e.contains(t.target)) return; const i = K.focusableChildren(e); 0 === i.length ? e.focus() : this._lastTabNavDirection === Te ? i[i.length - 1].focus() : i[0].focus() } _handleKeydown(t) { "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? Te : "forward") } } const Le = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Oe = ".sticky-top", Ie = "padding-right", De = "margin-right"; class Ne { constructor() { this._element = document.body } getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, Ie, (e => e + t)), this._setElementAttributes(Le, Ie, (e => e + t)), this._setElementAttributes(Oe, De, (e => e - t)) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Ie), this._resetElementAttributes(Le, Ie), this._resetElementAttributes(Oe, De) } isOverflowing() { return this.getWidth() > 0 } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(t, e, i) { const s = this.getWidth(); this._applyManipulationCallback(t, (t => { if (t !== this._element && window.innerWidth > t.clientWidth + s) return; this._saveInitialAttribute(t, e); const n = window.getComputedStyle(t).getPropertyValue(e); t.style.setProperty(e, `${i(Number.parseFloat(n))}px`) })) } _saveInitialAttribute(t, e) { const i = t.style.getPropertyValue(e); i && B.setDataAttribute(t, e, i) } _resetElementAttributes(t, e) { this._applyManipulationCallback(t, (t => { const i = B.getDataAttribute(t, e); null !== i ? (B.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e) })) } _applyManipulationCallback(t, e) { if (l(t)) e(t); else for (const i of K.find(t, this._element)) e(i) } } const Pe = ".bs.modal", xe = `hide${Pe}`, Me = `hidePrevented${Pe}`, je = `hidden${Pe}`, Fe = `show${Pe}`, ze = `shown${Pe}`, He = `resize${Pe}`, Be = `click.dismiss${Pe}`, qe = `mousedown.dismiss${Pe}`, We = `keydown.dismiss${Pe}`, Re = `click${Pe}.data-api`, Ke = "modal-open", Ve = "show", Qe = "modal-static", Xe = { backdrop: !0, focus: !0, keyboard: !0 }, Ye = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }; class Ue extends W { constructor(t, e) { super(t, e), this._dialog = K.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ne, this._addEventListeners() } static get Default() { return Xe } static get DefaultType() { return Ye } static get NAME() { return "modal" } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || this._isTransitioning || j.trigger(this._element, Fe, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Ke), this._adjustDialog(), this._backdrop.show((() => this._showElement(t)))) } hide() { this._isShown && !this._isTransitioning && (j.trigger(this._element, xe).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Ve), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated()))) } dispose() { j.off(window, Pe), j.off(this._dialog, Pe), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new we({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new Se({ trapElement: this._element }) } _showElement(t) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; const e = K.findOne(".modal-body", this._dialog); e && (e.scrollTop = 0), g(this._element), this._element.classList.add(Ve), this._queueCallback((() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, j.trigger(this._element, ze, { relatedTarget: t }) }), this._dialog, this._isAnimated()) } _addEventListeners() { j.on(this._element, We, (t => { "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition()) })), j.on(window, He, (() => { this._isShown && !this._isTransitioning && this._adjustDialog() })), j.on(this._element, qe, (t => { j.one(this._element, Be, (e => { this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition()) })) })) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => { document.body.classList.remove(Ke), this._resetAdjustments(), this._scrollBar.reset(), j.trigger(this._element, je) })) } _isAnimated() { return this._element.classList.contains("fade") } _triggerBackdropTransition() { if (j.trigger(this._element, Me).defaultPrevented) return; const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._element.style.overflowY; "hidden" === e || this._element.classList.contains(Qe) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Qe), this._queueCallback((() => { this._element.classList.remove(Qe), this._queueCallback((() => { this._element.style.overflowY = e }), this._dialog) }), this._dialog), this._element.focus()) } _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0; if (i && !t) { const t = p() ? "paddingLeft" : "paddingRight"; this._element.style[t] = `${e}px` } if (!i && t) { const t = p() ? "paddingRight" : "paddingLeft"; this._element.style[t] = `${e}px` } } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(t, e) { return this.each((function () { const i = Ue.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`); i[t](e) } })) } } j.on(document, Re, '[data-bs-toggle="modal"]', (function (t) { const e = K.getElementFromSelector(this);["A", "AREA"].includes(this.tagName) && t.preventDefault(), j.one(e, Fe, (t => { t.defaultPrevented || j.one(e, je, (() => { h(this) && this.focus() })) })); const i = K.findOne(".modal.show"); i && Ue.getInstance(i).hide(), Ue.getOrCreateInstance(e).toggle(this) })), V(Ue), b(Ue); const Ge = ".bs.offcanvas", Je = ".data-api", Ze = `load${Ge}${Je}`, ti = "show", ei = "showing", ii = "hiding", si = ".offcanvas.show", ni = `show${Ge}`, oi = `shown${Ge}`, ri = `hide${Ge}`, ai = `hidePrevented${Ge}`, li = `hidden${Ge}`, ci = `resize${Ge}`, hi = `click${Ge}${Je}`, di = `keydown.dismiss${Ge}`, ui = { backdrop: !0, keyboard: !0, scroll: !1 }, _i = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class gi extends W { constructor(t, e) { super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return ui } static get DefaultType() { return _i } static get NAME() { return "offcanvas" } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || j.trigger(this._element, ni, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new Ne).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(ei), this._queueCallback((() => { this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(ti), this._element.classList.remove(ei), j.trigger(this._element, oi, { relatedTarget: t }) }), this._element, !0)) } hide() { this._isShown && (j.trigger(this._element, ri).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(ii), this._backdrop.hide(), this._queueCallback((() => { this._element.classList.remove(ti, ii), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new Ne).reset(), j.trigger(this._element, li) }), this._element, !0))) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { const t = Boolean(this._config.backdrop); return new we({ className: "offcanvas-backdrop", isVisible: t, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: t ? () => { "static" !== this._config.backdrop ? this.hide() : j.trigger(this._element, ai) } : null }) } _initializeFocusTrap() { return new Se({ trapElement: this._element }) } _addEventListeners() { j.on(this._element, di, (t => { "Escape" === t.key && (this._config.keyboard ? this.hide() : j.trigger(this._element, ai)) })) } static jQueryInterface(t) { return this.each((function () { const e = gi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } j.on(document, hi, '[data-bs-toggle="offcanvas"]', (function (t) { const e = K.getElementFromSelector(this); if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), d(this)) return; j.one(e, li, (() => { h(this) && this.focus() })); const i = K.findOne(si); i && i !== e && gi.getInstance(i).hide(), gi.getOrCreateInstance(e).toggle(this) })), j.on(window, Ze, (() => { for (const t of K.find(si)) gi.getOrCreateInstance(t).show() })), j.on(window, ci, (() => { for (const t of K.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && gi.getOrCreateInstance(t).hide() })), V(gi), b(gi); const fi = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, mi = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), pi = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, bi = (t, e) => { const i = t.nodeName.toLowerCase(); return e.includes(i) ? !mi.has(i) || Boolean(pi.test(t.nodeValue)) : e.filter((t => t instanceof RegExp)).some((t => t.test(i))) }, vi = { allowList: fi, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" }, yi = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, wi = { entry: "(string|element|function|null)", selector: "(string|element)" }; class Ai extends q { constructor(t) { super(), this._config = this._getConfig(t) } static get Default() { return vi } static get DefaultType() { return yi } static get NAME() { return "TemplateFactory" } getContent() { return Object.values(this._config.content).map((t => this._resolvePossibleFunction(t))).filter(Boolean) } hasContent() { return this.getContent().length > 0 } changeContent(t) { return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this } toHtml() { const t = document.createElement("div"); t.innerHTML = this._maybeSanitize(this._config.template); for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e); const e = t.children[0], i = this._resolvePossibleFunction(this._config.extraClass); return i && e.classList.add(...i.split(" ")), e } _typeCheckConfig(t) { super._typeCheckConfig(t), this._checkContent(t.content) } _checkContent(t) { for (const [e, i] of Object.entries(t)) super._typeCheckConfig({ selector: e, entry: i }, wi) } _setContent(t, e, i) { const s = K.findOne(i, t); s && ((e = this._resolvePossibleFunction(e)) ? l(e) ? this._putElementInTemplate(c(e), s) : this._config.html ? s.innerHTML = this._maybeSanitize(e) : s.textContent = e : s.remove()) } _maybeSanitize(t) { return this._config.sanitize ? function (t, e, i) { if (!t.length) return t; if (i && "function" == typeof i) return i(t); const s = (new window.DOMParser).parseFromString(t, "text/html"), n = [].concat(...s.body.querySelectorAll("*")); for (const t of n) { const i = t.nodeName.toLowerCase(); if (!Object.keys(e).includes(i)) { t.remove(); continue } const s = [].concat(...t.attributes), n = [].concat(e["*"] || [], e[i] || []); for (const e of s) bi(e, n) || t.removeAttribute(e.nodeName) } return s.body.innerHTML }(t, this._config.allowList, this._config.sanitizeFn) : t } _resolvePossibleFunction(t) { return v(t, [this]) } _putElementInTemplate(t, e) { if (this._config.html) return e.innerHTML = "", void e.append(t); e.textContent = t.textContent } } const Ei = new Set(["sanitize", "allowList", "sanitizeFn"]), Ci = "fade", Ti = "show", ki = ".modal", $i = "hide.bs.modal", Si = "hover", Li = "focus", Oi = { AUTO: "auto", TOP: "top", RIGHT: p() ? "left" : "right", BOTTOM: "bottom", LEFT: p() ? "right" : "left" }, Ii = { allowList: fi, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 6], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, Di = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" }; class Ni extends W { constructor(t, e) { if (void 0 === i) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default() { return Ii } static get DefaultType() { return Di } static get NAME() { return "tooltip" } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle() { this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter()) } dispose() { clearTimeout(this._timeout), j.off(this._element.closest(ki), $i, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose() } show() { if ("none" === this._element.style.display) throw new Error("Please use show on visible elements"); if (!this._isWithContent() || !this._isEnabled) return; const t = j.trigger(this._element, this.constructor.eventName("show")), e = (u(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (t.defaultPrevented || !e) return; this._disposePopper(); const i = this._getTipElement(); this._element.setAttribute("aria-describedby", i.getAttribute("id")); const { container: s } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), j.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(Ti), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) j.on(t, "mouseover", _); this._queueCallback((() => { j.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1 }), this.tip, this._isAnimated()) } hide() { if (this._isShown() && !j.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) { if (this._getTipElement().classList.remove(Ti), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) j.off(t, "mouseover", _); this._activeTrigger.click = !1, this._activeTrigger[Li] = !1, this._activeTrigger[Si] = !1, this._isHovered = null, this._queueCallback((() => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), j.trigger(this._element, this.constructor.eventName("hidden"))) }), this.tip, this._isAnimated()) } } update() { this._popper && this._popper.update() } _isWithContent() { return Boolean(this._getTitle()) } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip } _createTipElement(t) { const e = this._getTemplateFactory(t).toHtml(); if (!e) return null; e.classList.remove(Ci, Ti), e.classList.add(`bs-${this.constructor.NAME}-auto`); const i = (t => { do { t += Math.floor(1e6 * Math.random()) } while (document.getElementById(t)); return t })(this.constructor.NAME).toString(); return e.setAttribute("id", i), this._isAnimated() && e.classList.add(Ci), e } setContent(t) { this._newContent = t, this._isShown() && (this._disposePopper(), this.show()) } _getTemplateFactory(t) { return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Ai({ ...this._config, content: t, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { ".tooltip-inner": this._getTitle() } } _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title") } _initializeOnDelegatedTarget(t) { return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(Ci) } _isShown() { return this.tip && this.tip.classList.contains(Ti) } _createPopper(t) { const e = v(this._config.placement, [this, t, this._element]), s = Oi[e.toUpperCase()]; return i.createPopper(this._element, t, this._getPopperConfig(s)) } _getOffset() { const { offset: t } = this._config; return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t } _resolvePossibleFunction(t) { return v(t, [this._element]) } _getPopperConfig(t) { const e = { placement: t, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: t => { this._getTipElement().setAttribute("data-popper-placement", t.state.placement) } }] }; return { ...e, ...v(this._config.popperConfig, [e]) } } _setListeners() { const t = this._config.trigger.split(" "); for (const e of t) if ("click" === e) j.on(this._element, this.constructor.eventName("click"), this._config.selector, (t => { this._initializeOnDelegatedTarget(t).toggle() })); else if ("manual" !== e) { const t = e === Si ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i = e === Si ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout"); j.on(this._element, t, this._config.selector, (t => { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger["focusin" === t.type ? Li : Si] = !0, e._enter() })), j.on(this._element, i, this._config.selector, (t => { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger["focusout" === t.type ? Li : Si] = e._element.contains(t.relatedTarget), e._leave() })) } this._hideModalHandler = () => { this._element && this.hide() }, j.on(this._element.closest(ki), $i, this._hideModalHandler) } _fixTitle() { const t = this._element.getAttribute("title"); t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title")) } _enter() { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => { this._isHovered && this.show() }), this._config.delay.show)) } _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => { this._isHovered || this.hide() }), this._config.delay.hide)) } _setTimeout(t, e) { clearTimeout(this._timeout), this._timeout = setTimeout(t, e) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(t) { const e = B.getDataAttributes(this._element); for (const t of Object.keys(e)) Ei.has(t) && delete e[t]; return t = { ...e, ..."object" == typeof t && t ? t : {} }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } _configAfterMerge(t) { return t.container = !1 === t.container ? document.body : c(t.container), "number" == typeof t.delay && (t.delay = { show: t.delay, hide: t.delay }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t } _getDelegateConfig() { const t = {}; for (const [e, i] of Object.entries(this._config)) this.constructor.Default[e] !== i && (t[e] = i); return t.selector = !1, t.trigger = "manual", t } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface(t) { return this.each((function () { const e = Ni.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } b(Ni); const Pi = { ...Ni.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, xi = { ...Ni.DefaultType, content: "(null|string|element|function)" }; class Mi extends Ni { static get Default() { return Pi } static get DefaultType() { return xi } static get NAME() { return "popover" } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(t) { return this.each((function () { const e = Mi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } b(Mi); const ji = ".bs.scrollspy", Fi = `activate${ji}`, zi = `click${ji}`, Hi = `load${ji}.data-api`, Bi = "active", qi = "[href]", Wi = ".nav-link", Ri = `${Wi}, .nav-item > ${Wi}, .list-group-item`, Ki = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1] }, Vi = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" }; class Qi extends W { constructor(t, e) { super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return Ki } static get DefaultType() { return Vi } static get NAME() { return "scrollspy" } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const t of this._observableSections.values()) this._observer.observe(t) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(t) { return t.target = c(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t => Number.parseFloat(t)))), t } _maybeEnableSmoothScroll() { this._config.smoothScroll && (j.off(this._config.target, zi), j.on(this._config.target, zi, qi, (t => { const e = this._observableSections.get(t.target.hash); if (e) { t.preventDefault(); const i = this._rootElement || window, s = e.offsetTop - this._element.offsetTop; if (i.scrollTo) return void i.scrollTo({ top: s, behavior: "smooth" }); i.scrollTop = s } }))) } _getNewObserver() { const t = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver((t => this._observerCallback(t)), t) } _observerCallback(t) { const e = t => this._targetLinks.get(`#${t.target.id}`), i = t => { this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t)) }, s = (this._rootElement || document.documentElement).scrollTop, n = s >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = s; for (const o of t) { if (!o.isIntersecting) { this._activeTarget = null, this._clearActiveClass(e(o)); continue } const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (n && t) { if (i(o), !s) return } else n || t || i(o) } } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; const t = K.find(qi, this._config.target); for (const e of t) { if (!e.hash || d(e)) continue; const t = K.findOne(decodeURI(e.hash), this._element); h(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t)) } } _process(t) { this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Bi), this._activateParents(t), j.trigger(this._element, Fi, { relatedTarget: t })) } _activateParents(t) { if (t.classList.contains("dropdown-item")) K.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(Bi); else for (const e of K.parents(t, ".nav, .list-group")) for (const t of K.prev(e, Ri)) t.classList.add(Bi) } _clearActiveClass(t) { t.classList.remove(Bi); const e = K.find(`${qi}.${Bi}`, t); for (const t of e) t.classList.remove(Bi) } static jQueryInterface(t) { return this.each((function () { const e = Qi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } j.on(window, Hi, (() => { for (const t of K.find('[data-bs-spy="scroll"]')) Qi.getOrCreateInstance(t) })), b(Qi); const Xi = ".bs.tab", Yi = `hide${Xi}`, Ui = `hidden${Xi}`, Gi = `show${Xi}`, Ji = `shown${Xi}`, Zi = `click${Xi}`, ts = `keydown${Xi}`, es = `load${Xi}`, is = "ArrowLeft", ss = "ArrowRight", ns = "ArrowUp", os = "ArrowDown", rs = "Home", as = "End", ls = "active", cs = "fade", hs = "show", ds = ".dropdown-toggle", us = `:not(${ds})`, _s = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', gs = `.nav-link${us}, .list-group-item${us}, [role="tab"]${us}, ${_s}`, fs = `.${ls}[data-bs-toggle="tab"], .${ls}[data-bs-toggle="pill"], .${ls}[data-bs-toggle="list"]`; class ms extends W { constructor(t) { super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), j.on(this._element, ts, (t => this._keydown(t)))) } static get NAME() { return "tab" } show() { const t = this._element; if (this._elemIsActive(t)) return; const e = this._getActiveElem(), i = e ? j.trigger(e, Yi, { relatedTarget: t }) : null; j.trigger(t, Gi, { relatedTarget: e }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e)) } _activate(t, e) { t && (t.classList.add(ls), this._activate(K.getElementFromSelector(t)), this._queueCallback((() => { "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), j.trigger(t, Ji, { relatedTarget: e })) : t.classList.add(hs) }), t, t.classList.contains(cs))) } _deactivate(t, e) { t && (t.classList.remove(ls), t.blur(), this._deactivate(K.getElementFromSelector(t)), this._queueCallback((() => { "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), j.trigger(t, Ui, { relatedTarget: e })) : t.classList.remove(hs) }), t, t.classList.contains(cs))) } _keydown(t) { if (![is, ss, ns, os, rs, as].includes(t.key)) return; t.stopPropagation(), t.preventDefault(); const e = this._getChildren().filter((t => !d(t))); let i; if ([rs, as].includes(t.key)) i = e[t.key === rs ? 0 : e.length - 1]; else { const s = [ss, os].includes(t.key); i = w(e, t.target, s, !0) } i && (i.focus({ preventScroll: !0 }), ms.getOrCreateInstance(i).show()) } _getChildren() { return K.find(gs, this._parent) } _getActiveElem() { return this._getChildren().find((t => this._elemIsActive(t))) || null } _setInitialAttributes(t, e) { this._setAttributeIfNotExists(t, "role", "tablist"); for (const t of e) this._setInitialAttributesOnChild(t) } _setInitialAttributesOnChild(t) { t = this._getInnerElement(t); const e = this._elemIsActive(t), i = this._getOuterElement(t); t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t) } _setInitialAttributesOnTargetPanel(t) { const e = K.getElementFromSelector(t); e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`)) } _toggleDropDown(t, e) { const i = this._getOuterElement(t); if (!i.classList.contains("dropdown")) return; const s = (t, s) => { const n = K.findOne(t, i); n && n.classList.toggle(s, e) }; s(ds, ls), s(".dropdown-menu", hs), i.setAttribute("aria-expanded", e) } _setAttributeIfNotExists(t, e, i) { t.hasAttribute(e) || t.setAttribute(e, i) } _elemIsActive(t) { return t.classList.contains(ls) } _getInnerElement(t) { return t.matches(gs) ? t : K.findOne(gs, t) } _getOuterElement(t) { return t.closest(".nav-item, .list-group-item") || t } static jQueryInterface(t) { return this.each((function () { const e = ms.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } j.on(document, Zi, _s, (function (t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), d(this) || ms.getOrCreateInstance(this).show() })), j.on(window, es, (() => { for (const t of K.find(fs)) ms.getOrCreateInstance(t) })), b(ms); const ps = ".bs.toast", bs = `mouseover${ps}`, vs = `mouseout${ps}`, ys = `focusin${ps}`, ws = `focusout${ps}`, As = `hide${ps}`, Es = `hidden${ps}`, Cs = `show${ps}`, Ts = `shown${ps}`, ks = "hide", $s = "show", Ss = "showing", Ls = { animation: "boolean", autohide: "boolean", delay: "number" }, Os = { animation: !0, autohide: !0, delay: 5e3 }; class Is extends W { constructor(t, e) { super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return Os } static get DefaultType() { return Ls } static get NAME() { return "toast" } show() { j.trigger(this._element, Cs).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(ks), g(this._element), this._element.classList.add($s, Ss), this._queueCallback((() => { this._element.classList.remove(Ss), j.trigger(this._element, Ts), this._maybeScheduleHide() }), this._element, this._config.animation)) } hide() { this.isShown() && (j.trigger(this._element, As).defaultPrevented || (this._element.classList.add(Ss), this._queueCallback((() => { this._element.classList.add(ks), this._element.classList.remove(Ss, $s), j.trigger(this._element, Es) }), this._element, this._config.animation))) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove($s), super.dispose() } isShown() { return this._element.classList.contains($s) } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide() }), this._config.delay))) } _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e }if (e) return void this._clearTimeout(); const i = t.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide() } _setListeners() { j.on(this._element, bs, (t => this._onInteraction(t, !0))), j.on(this._element, vs, (t => this._onInteraction(t, !1))), j.on(this._element, ys, (t => this._onInteraction(t, !0))), j.on(this._element, ws, (t => this._onInteraction(t, !1))) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each((function () { const e = Is.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } return V(Is), b(Is), { Alert: U, Button: J, Carousel: Ot, Collapse: Rt, Dropdown: fe, Modal: Ue, Offcanvas: gi, Popover: Mi, ScrollSpy: Qi, Tab: ms, Toast: Is, Tooltip: Ni } }));

(function (Drupal) { Drupal.behaviors.myCustomBlock = { attach: function (context, settings) { const block = document.querySelector('.custom-block'); const popup = document.getElementById("popup"); const closePopup = document.getElementById("closePopup"); const popupDismissed = localStorage.getItem("popupDismissed"); const now = new Date().getTime(); if (!popupDismissed || now - popupDismissed > 24 * 60 * 60 * 1000) popup.classList.add("show"); closePopup.addEventListener("click", function () { popup.classList.remove("show"); localStorage.setItem("popupDismissed", new Date().getTime()); }); } }; })(Drupal);;
"use strict"; var Selectors; !function (e) { e.stacked = "tabled--stacked", e.table = "tabled__table", e.columnLarge = "tabled__column--large", e.columnSmall = "tabled__column--small", e.wrapper = "tabled__wrapper", e.container = "tabled", e.fadeLeft = "tabled--fade-left", e.fadeRight = "tabled--fade-right", e.navigation = "tabled__navigation", e.previous = "tabled__previous", e.next = "tabled__next", e.caption = "tabled__caption" }(Selectors = Selectors || {}); class Tabled { constructor(e) { if (e.index || (e.index = Math.floor(1e4 * Math.random())), this.checkConditions(e.table)) { e.table.classList.add(Selectors.table), this.wrap(e.table); var t = this.getWrapper(e.table); t.setAttribute("id", "tabled-n" + e.index), this.adjustColumnsWidth(e), this.addTableControls(e), this.applyFade(e.table), t.addEventListener("scroll", () => { this.applyFade(e.table) }), new ResizeObserver(() => { this.applyFade(e.table) }).observe(t) } else if (e.table.classList.contains(Selectors.stacked)) { const a = Array.from(e.table.querySelectorAll("thead th")); Array.from(e.table.querySelectorAll("tbody tr")).forEach(e => { Array.from(e.querySelectorAll("td, th")).forEach((e, t) => { t = a[t]; t && e.setAttribute("data-label", t.innerText + ": ") }) }) } else e.failClass && e.table.classList.add(e.failClass) } getWrapper(e) { return e.parentNode } getContainer(e) { return e.parentNode ? e.parentNode.parentNode : null } adjustColumnsWidth(e) { var t, a; const l = null != (t = e.characterThresholdLarge) ? t : 50, s = null != (t = e.characterThresholdSmall) ? t : 8; for (a of e.table.rows) Array.from(a.cells).forEach(e => { e.innerText.length > l ? e.classList.add(Selectors.columnLarge) : e.innerText.length <= s && e.classList.add(Selectors.columnSmall) }) } wrap(e) { var t = document.createElement("div"), e = (t.classList.add(Selectors.wrapper), t.setAttribute("tabindex", "0"), e.parentNode.insertBefore(t, e), t.appendChild(e), document.createElement("div")); e.classList.add(Selectors.container), t.parentNode.insertBefore(e, t), e.appendChild(t) } applyFade(e) { var e = this.getWrapper(e), t = e.parentNode, a = t.getElementsByClassName(Selectors.previous)[0], l = t.getElementsByClassName(Selectors.next)[0], a = (1 < e.scrollLeft ? (t.classList.add(Selectors.fadeLeft), a.removeAttribute("disabled")) : (t.classList.remove(Selectors.fadeLeft), a.setAttribute("disabled", "disabled")), e.offsetWidth); e.scrollWidth - e.scrollLeft - a < 1 ? (t.classList.remove(Selectors.fadeRight), l.setAttribute("disabled", "disabled")) : (t.classList.add(Selectors.fadeRight), l.removeAttribute("disabled")) } move(e, t = "previous") { var a, l = this.getWrapper(e), s = null != (a = null == (a = l.parentNode) ? void 0 : a.getBoundingClientRect().left) ? a : 0, r = (1 < e.rows[0].cells.length ? e.rows[0] : e.rows[1]).cells; let o = 0, i = 0; if ("next" == t) for (let e = 0; e < r.length; e++) { var d = r[e].getClientRects()[0].left; if (1 < (o = d - s)) { i = r[e].offsetLeft; break } } else if ("previous" == t) for (let e = r.length - 1; 0 < e; e--) { var n = r[e].getClientRects()[0].left; if ((o = n - s) < 0) { i = r[e].offsetLeft; break } } l.scrollTo({ left: i, top: 0, behavior: "smooth" }) } addTableControls(e) { const a = e.table, l = document.createElement("div"); l.classList.add(Selectors.navigation), ["previous", "next"].forEach(e => { var t = document.createElement("button"); t.classList.add("tabled__" + e), t.setAttribute("aria-label", e + " table column"), t.setAttribute("aria-controls", this.getWrapper(a).getAttribute("id")), t.setAttribute("disabled", "disabled"), t.setAttribute("type", "button"), t.addEventListener("click", () => { this.move(a, e) }), l.appendChild(t) }); var t, s = this.getContainer(a), s = (s && s.prepend(l), a.querySelector("caption")); s && (s.classList.add("visually-hidden"), !s.classList.contains("hide-caption")) && ((t = document.createElement("div")).classList.add(Selectors.caption), "bottom" === e.captionSide && t.classList.add("tabled__caption--bottom"), t.innerHTML = s.innerText, t.setAttribute("aria-hidden", "true"), s = this.getContainer(a)) && ("bottom" === e.captionSide ? s.appendChild(t) : s.prepend(t)) } checkConditions(e) { return !(e.classList.contains(Selectors.stacked) || e.querySelector("table") || !e.querySelector("table > tbody") || document.evaluate("ancestor::table", e, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue) } }
;
'use strict'; (function tabledInit(drupalSettings) { document.querySelectorAll(drupalSettings.ckeditorResponsiveTable.tableSelector).forEach((table) => new Tabled({ table, failClass: 'tabled--stacked' })); })(window.drupalSettings);;
"use strict"; (function (a) { a.behaviors.faqs = { attach: function (a) { once("faqs", "[data-drupal-selector=\"faqs\"]", a).forEach(function (a) { var b = a.querySelectorAll("[data-drupal-selector=\"faqs-item\"]"); b.forEach(function (a) { var c = a.querySelector(".faqs-item__header"); c.addEventListener("click", function () { for (var c = 0; c <= b.length - 1; c++)b[c] === a ? b[c].classList.toggle("faqs-item--active") : b[c].classList.remove("faqs-item--active"); }); }); }); } }; })(Drupal);;
"use strict"; (function (a, b) { function c(a, b) { if (a && b && 768 <= window.innerWidth) { var c = new IntersectionObserver(function (b) { b.forEach(function (b) { 0 < !b.isVisible && !b.isIntersecting && 0 > b.boundingClientRect.top ? a.classList.add("active") : a.classList.remove("active"); }); }, { root: null, threshold: 0 }); c.observe(b); } } a.behaviors.gridCta = { attach: function (a) { b("gridCtaInit", "[data-drupal-selector=\"grid-cta\"]", a).forEach(function (a) { var b = a.querySelector("[data-drupal-selector=\"grid-cta-floating-icon\"]"), d = a.querySelector("[data-drupal-selector=\"grid-cta-items-parent\"]"), e = a.querySelector("[data-drupal-selector=\"grid-cta-popup\"]"), f = document.querySelector(".region--sticky-content .grid-cta"), g = document.querySelector(".region--sticky-content"); g && f && (f.classList.add("hide"), g.classList.add("hide")); document.body.classList.contains("page--node-type-hospitals"); e && d && c(e, d); }); } }; })(Drupal, once);;
"use strict"; (function (a, b) { function c(a) { a instanceof HTMLVideoElement && (a.setAttribute("autoplay", "autoplay"), a.setAttribute("loop", "true"), a.setAttribute("playsinline", "true"), a.removeAttribute("controls"), a.muted = !0, a.play()["catch"](function (a) { console.error("Autoplay failed:", a); })); } a.behaviors.heroBanner = { attach: function (a) { b("heroBannerInit", "[data-drupal-selector=\"hero-banner\"]", a).forEach(function (a) { var b = a.querySelectorAll("video"); b && b.length && (c(b[0]), c(b[1])); }); } }; })(Drupal, once);;
"use strict"; (function (a, b) { a.behaviors.textBlockSplide = { attach: function (a) { b("splideInit", "[data-drupal-selector=\"image-text-block-slider\"]", a).forEach(function (a) { var b, c = a.closest(".no-slider"), d = function () { return c && 992 <= window.innerWidth ? void (b && (b.destroy(!0), b = null)) : void (!b && (b = new window.Splide(a, { type: c ? "slide" : "loop", focus: "left", arrows: !0, padding: { left: 0, right: "3.5rem" }, gap: "1rem", autoWidth: !0, mediaQuery: "min", breakpoints: { 992: { perPage: 2, perMove: 2, autoplay: "true", padding: !1, pagination: !1, dots: !1 }, 320: { perPage: 1, pagination: !0, dots: !0 } } }), b.mount())); }; d(), window.addEventListener("resize", function () { d(); }); }); } }; })(Drupal, once);;
"use strict"; window.Drupal.youtubeVideoArray = []; function onYouTubeIframeAPIReady() { var a = document.querySelectorAll(".iframe-youtube-local"); a.forEach(function (a) { var b = new window.YT.Player(a, {}); window.Drupal.youtubeVideoArray.push(b); }); } (function (a, b) { var c = function () { window.Drupal.youtubeVideoArray.forEach(function (a) { a.getPlayerState() === window.YT.PlayerState.PLAYING && a.pauseVideo(); }); var a = document.querySelectorAll(".video-internal-local"); a.forEach(function (a) { a.paused || a.pause(); }); }, d = function (a) { var b = document, c = b.body, d = new MutationObserver(function () { a(); }); d.observe(c, { attributes: !0, attributeFilter: ["class"] }); }, e = function (a) { var b = document, d = b.body; d.classList.contains("modal-open") ? a.Components.AutoScroll && a.Components.AutoScroll.pause() : (a.Components.AutoScroll && a.Components.AutoScroll.play(), c()); }, f = function (a) { a.on("move", function (b, c) { var d = a.Components.Slides.getAt(c).slide, e = d.querySelector(".iframe-youtube-local"); if (e) { var f = window.Drupal.youtubeVideoArray.find(function (a) { return a.getIframe() === e; }); f && f.pauseVideo(); } var g = d.querySelector(".video-internal-local"); g && !g.paused && g.pause(); }); }, g = function () { if (!window.YT || "function" != typeof window.YT.Player) { var a = document.createElement("script"); a.src = "https://www.youtube.com/iframe_api", document.head.appendChild(a); } }; a.behaviors.testimonialsSlider = { attach: function (a) { b("testimonials-initialized", "[data-drupal-selector=\"testimonials\"]", a).forEach(function (a) { var b = a.closest(".right-to-left"), h = b ? 1 : -1, i = new window.Splide(a, { type: "loop", drag: "free", focus: "center", perPage: 3, autoScroll: { speed: h }, arrows: !1, pagination: !1, dots: !1, autoWidth: !0, mediaQuery: "min", breakpoints: { 992: { height: "18rem", gap: "1.5rem" }, 320: { height: "16.5rem", gap: "1.125rem" } } }); i.mount(window.splide.Extensions); var j = document, k = j.body, l = function (a) { a.preventDefault(); var b = a.target.closest(".modal-button"); if (b) b.getAttribute("data-video-url"); }, m = document.querySelectorAll(".modal-header .close"); m.forEach(function (a) { a.addEventListener("click", function () { c(), e(i); }); }), document.addEventListener("click", function (a) { var b = document.querySelector(".modal"), c = a.target.closest(".modal-button"); c && (l(a), e(i)); }), d(function () { return e(i); }), f(i), g(); }); } }, a.behaviors.storiesSlider = { attach: function (a) { b("testimonials-stories-initialized", "[data-drupal-selector=\"testimonials-stories\"]", a).forEach(function (a) { var b = a.querySelector(".testimonials-stories"), e = b.classList.contains("doctor-review-stories"), h = { type: "slide", focus: "left", perMove: 1, arrows: !0, padding: { left: "0", right: "7%" }, mediaQuery: "min", breakpoints: { 1200: { perPage: e ? 2 : 1.4, perMove: e ? 2 : 1, padding: { left: "0", right: e ? "12%" : "7%" } }, 992: { gap: "1.5rem", pagination: !1, dots: !1, perPage: e ? 1.2 : 1.1 }, 320: { gap: "1rem", pagination: !0, dots: !0, perPage: 1.1 } } }, i = new window.Splide(a, h); i.mount(); var j = document, k = j.body, l = document.querySelectorAll(".modal-header .close"); l.forEach(function (a) { a.addEventListener("click", c); }), document.addEventListener("click", function (a) { var b = document.querySelector(".modal"); !b || b.contains(a.target) || a.target.closest(".modal") || k.classList.contains("modal-open") || c(); }), d(function () { k.classList.contains("modal-open") || c(); }), f(i), g(); }); } }; })(Drupal, once);;
"use strict"; (function (a) { var b = document.querySelector("body"); a.behaviors.menu = { attach: function (a) { once("menu-initialized", "[data-drupal-selector=\"menu-main\"]", a).forEach(function (a) { var c = a.querySelectorAll(".menu-level-0 > .menu__item"), d = a.querySelectorAll(".menu-level-1"), e = a.querySelectorAll(".menu-level-1__list > .menu__item"), f = a.querySelectorAll(".menu-level-1__content > .menu-inner-content"), g = a.querySelectorAll(".menu-level-2"), h = a.querySelector(".quick-links.desktop"), i = a.querySelectorAll(".menu-cross"), j = a.querySelectorAll(".hospitals-menu .menu-level-1__list > .menu__item:not(.hide)"), k = function (a) { if (a && a.parentElement.classList.contains("menu-level-1__list") && a.classList.contains("shrink-items")) { var b = a.getAttribute("data-attr"); if (b) { var c = a.closest(".menu-level-1__wrapper").querySelector(".menu-inner-content[data-attr=\"".concat(b, "\"]")); if (c) { var d = c.querySelector(".menu-level-2"); d && d.classList.add("shrink-items"); } } } }, l = function () { c.forEach(function (b) { if (b.classList.contains("active")) { var c = b.querySelector(".quick-links.desktop"); e.forEach(function (b) { if (b.classList.contains("active")) { var d = a.querySelector(".menu-level-1__content > .menu-inner-content[data-attr=\"".concat(b.getAttribute("data-attr"), "\"]")); if (d && d.classList.contains("active")) { var e = d.querySelector(".menu-level-2"); if (e) { var f = e.querySelectorAll("li").length; 16 < f ? c.classList.add("hidden") : c.classList.remove("hidden"); } } } }); } }); }, m = function (a) { var g = a.currentTarget; a.stopPropagation(), g.classList.contains("menu__item--expanded") && b.classList.add("no-scroll"), d.forEach(function (a) { return a.classList.remove("active"); }), e.forEach(function (a) { return a.classList.remove("active"); }), c.forEach(function (a) { return a.classList.remove("active"); }), f.forEach(function (a) { return a.classList.remove("active"); }), g.classList.add("active"); var h = g.querySelector(".menu-level-1"); if (h) { h.classList.add("active"); var i = h.querySelector(".menu-level-1__list .menu__item:first-of-type"); i && i.classList.contains("shrink-items") && k(i); var j = h.querySelector(".menu-level-1__wrapper"), m = j.querySelector(".quick-links.desktop"), n = j.querySelector(".menu-inner-content:first-of-type .menu-level-2"); if (n && !n.closest(".menu-level-1").closest(".menu__item").classList.contains("hospitals-menu") && 16 < n.getAttribute("data-children-count") ? m.classList.add("hidden") : m.classList.remove("hidden"), i && !i.closest(".menu-level-1").closest(".menu__item").classList.contains("hospitals-menu") && i.classList.contains("hide")) { var o = h.querySelector(".menu-level-1__list .menu__item:not(.hide)"); if (o) { o.classList.add("show-first"); var p = h.querySelector(".menu-level-1__content > .menu-inner-content:not(.hide)"); p && p.classList.add("show-first"); var q = j.querySelector(".menu-inner-content:not(.hide) .menu-level-2"); q && 16 < q.getAttribute("data-children-count") ? m.classList.add("hidden") : m.classList.remove("hidden"); } } } l(); }, n = function (a) { var c = a.currentTarget; b.classList.remove("no-scroll"); var d = document.querySelectorAll(".menu .menu-level-1__list.hovered-item"); d && d.length && d.forEach(function (a) { return a.classList.remove("hovered-item"); }), c.classList.remove("active"); var e = c.querySelector(".menu-level-1"); e && e.classList.remove("active"), f.forEach(function (a) { return a.classList.remove("active"); }), l(); }, o = function (a) { var b = a.currentTarget, c = b.closest(".menu-level-1__list"); a.stopPropagation(), c && c.classList.add("hovered-item"); var d = b.getAttribute("data-attr"); e.forEach(function (a) { return a.classList.remove("active"); }), f.forEach(function (a) { return a.classList.remove("active"); }), b.classList.add("active"), f.forEach(function (a) { a.getAttribute("data-attr") === d && a.classList.add("active"); }), k(b), l(); }, p = function () { g.forEach(function (a) { var b; a.querySelectorAll("li") && (b = a.querySelectorAll("li").length), a.setAttribute("data-children-count", b), 1024 <= window.innerWidth && 16 < b ? a.classList.add("col-3") : a.classList.remove("col-3"); }); }, q = function () { if (j && 0 < j.length) { var a = j[0], b = a.getAttribute("data-attr"); if (b) { var c = a.closest(".menu-level-1__wrapper").querySelector(".menu-level-1__content .menu-inner-content:not(.hide)"), d = a.closest(".menu-level-1__wrapper").querySelector(".quick-links"); if (c && d) { var e = c.querySelector(".menu-level-2").getAttribute("data-children-count"); e && 32 < e ? d.classList.add("hidden") : d.classList.remove("hidden"); } } } }, r = function (a) { a.stopPropagation(); var b = a.currentTarget, c = b.closest(".menu-level-0 > .menu__item"), d = b.closest(".menu-level-1"); c && c.classList.remove("active"), d && d.classList.remove("active"), f.forEach(function (a) { return a.classList.remove("active"); }), l(); }, s = function () { c.forEach(function (a) { a.addEventListener("mouseenter", m), a.addEventListener("mouseleave", n); }), e.forEach(function (a) { a.addEventListener("mouseenter", o); }), p(), q(); }, t = function () { c.forEach(function (a) { a.removeEventListener("mouseenter", m), a.removeEventListener("mouseleave", n); }), e.forEach(function (a) { a.removeEventListener("mouseenter", o); }), h.classList.remove("hidden"); }; 1024 <= window.innerWidth ? s() : t(), i.forEach(function (a) { a.addEventListener("click", r); }), window.addEventListener("resize", function () { var a = 1024 <= window.innerWidth; document.querySelectorAll(".menu .active").forEach(function (a) { return a.classList.remove("active"); }), a ? s() : t(); }); }); } }, a.behaviors.mobileMenu = { attach: function (a) { once("mobile-menu-initialized", "[data-drupal-selector=\"menu\"]", a).forEach(function (a) { var b = a.querySelector(".menu-toggle"), c = a.querySelector(".nav-menu"), d = a.querySelectorAll(".menu-level-0 > .menu__item > .menu-icon"), e = a.querySelectorAll(".menu-level-1"), f = a.querySelectorAll(".menu-level-1__list > .menu__item"), g = a.querySelectorAll(".menu-level-1__content"), h = a.querySelectorAll(".menu-level-1__content > .menu-inner-content"), i = a.querySelectorAll(".back-btn-1"), j = a.querySelectorAll(".back-btn-2"), k = 1024 <= window.innerWidth, l = function () { a.querySelectorAll(".active").forEach(function (a) { return a.classList.remove("active"); }); }, m = function (a, b) { if (e.forEach(function (a) { return a.classList.remove("active"); }), e[b].classList.add("active"), e[b].closest(".menu__item").classList.contains("hospitals-menu")) { var c = e[b].querySelector(".menu-level-1__list .menu__item:not(.hide)"); c && c.click(); } }, n = function () { e.forEach(function (a) { return a.classList.remove("active"); }), g.forEach(function (a) { return a.classList.remove("active"); }), h.forEach(function (a) { return a.classList.remove("active"); }), f.forEach(function (a) { return a.classList.remove("active"); }); }, o = function (a) { if (h.forEach(function (a) { return a.classList.remove("active"); }), g.forEach(function (a) { return a.classList.remove("active"); }), a.target.classList.contains("back-btn-2")) { var b = a.target.closest(".menu-inner-content"); if (b && b.classList.contains("hospital-active")) { var c = b.closest(".menu-level-1"); c && c.classList.contains("active") && c.querySelector(".back-btn-1").click(); } } }, p = function (a) { var b = a.closest(".menu-level-1"); if (b && b.classList.contains("active")) { var c = a.getAttribute("data-attr"), d = b.querySelectorAll(".menu-level-1__content"), e = b.querySelectorAll(".menu-inner-content"), f = b.querySelectorAll(".menu__item"); f.forEach(function (a) { return a.classList.remove("active"); }), d.forEach(function (a) { return a.classList.remove("active"); }), e.forEach(function (a) { return a.classList.remove("active"); }), a.classList.add("active"); var g = b.querySelector(".menu-level-1__content[data-attr=\"".concat(c, "\"]")); g && g.classList.add("active"), e.forEach(function (a) { a.getAttribute("data-attr") === c && a.classList.add("active"); }); } }, q = function () { l(), d.forEach(function (a) { a.removeEventListener("click", m); }); }, r = function () { l(), d.forEach(function (a, b) { a.addEventListener("click", function () { return m(a, b); }); }), i.forEach(function (a) { a.addEventListener("click", n); }), f.forEach(function (a) { a.addEventListener("click", function () { return p(a); }); }), j.forEach(function (a) { a.addEventListener("click", o); }); }, s = function () { k ? q() : r(); }; b.addEventListener("click", function () { b.classList.toggle("active"), c.classList.toggle("active"), b.classList.contains("active") || l(), c.classList.contains("active") ? document.body.classList.add("no-scroll") : document.body.classList.remove("no-scroll"); }), s(), window.addEventListener("resize", function () { var a = 1024 <= window.innerWidth; a !== k && (k = a, s()); }); }); } }, a.behaviors.stickyHeader = { attach: function (a) { once("sticky-init", "[data-drupal-selector=\"header-main\"]", a).forEach(function (a) { var b = a.querySelector(".header-region"); window.addEventListener("scroll", function () { window.scrollY > 200 ? b.classList.add("sticky") : b.classList.remove("sticky"); }); }); } }; })(Drupal);;
"use strict"; function _slicedToArray(a, b) { return _arrayWithHoles(a) || _iterableToArrayLimit(a, b) || _unsupportedIterableToArray(a, b) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } function _unsupportedIterableToArray(b, c) { if (b) { if ("string" == typeof b) return _arrayLikeToArray(b, c); var a = {}.toString.call(b).slice(8, -1); return "Object" === a && b.constructor && (a = b.constructor.name), "Map" === a || "Set" === a ? Array.from(b) : "Arguments" === a || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? _arrayLikeToArray(b, c) : void 0; } } function _arrayLikeToArray(b, c) { (null == c || c > b.length) && (c = b.length); for (var d = 0, f = Array(c); d < c; d++)f[d] = b[d]; return f; } function _iterableToArrayLimit(b, c) { var d = null == b ? null : "undefined" != typeof Symbol && b[Symbol.iterator] || b["@@iterator"]; if (null != d) { var g, h, j, k, l = [], a = !0, m = !1; try { if (j = (d = d.call(b)).next, 0 === c) { if (Object(d) !== d) return; a = !1; } else for (; !(a = (g = j.call(d)).done) && (l.push(g.value), l.length !== c); a = !0); } catch (a) { m = !0, h = a; } finally { try { if (!a && null != d["return"] && (k = d["return"](), Object(k) !== k)) return; } finally { if (m) throw h; } } return l; } } function _arrayWithHoles(a) { if (Array.isArray(a)) return a; } (function (a, b) { a.behaviors.modalInit = { attach: function (a) { once("hover-card", "[data-drupal-selector=\"modal-button\"]", a).forEach(function (a) { var c = a.getAttribute("data-target"), d = document.querySelectorAll(".modal-header .close"), e = function (a) { if (!a) return null; var b = null, c = a.match(/[?&]v=([^&#]*)/); if (c) { var d = _slicedToArray(c, 2); b = d[1]; } else { var e = a.match(/youtu\.be\/([^?&#]*)/); if (e) { var f = _slicedToArray(e, 2); b = f[1]; } else { var g = a.match(/youtube\.com\/shorts\/([^?&#]*)/); if (g) { var h = _slicedToArray(g, 2); b = h[1]; } } } return b; }; if (c) { var f = document.getElementById(c); f && (document.body.append(f), a.addEventListener("click", function (a) { a.preventDefault(), f && b(f).modal("show"); })); } a.addEventListener("click", function (c) { c.preventDefault(); var d = c.target.closest(".modal-button").getAttribute("data-target"), f = document.getElementById(d); if (f) { b(f).modal("show"); var g = a.getAttribute("data-video-url"), h = e(g), i = document.createElement("iframe"); if (h) { var j = "https://www.youtube.com/embed/".concat(h, "?enablejsapi=1&rel=0&autoplay=1"); i.setAttribute("src", j); } i.setAttribute("frameborder", "0"), i.setAttribute("allow", "autoplay; fullscreen"), i.setAttribute("allowfullscreen", ""), i.setAttribute("class", "iframe-youtube-local"), i.setAttribute("id", "testimonial-video"); var k = f.querySelector(".modal-body"); k && (k.innerHTML = "", k.appendChild(i)); } }), d.forEach(function (a) { a.addEventListener("click", function (a) { var b = a.target.closest(".modal"); if (b) { var c = b.querySelector(".modal-body"); c && (c.innerHTML = ""); } }); }), b(".modal").on("hidden.bs.modal", function () { var a = this.querySelector(".modal-body"); a && (a.innerHTML = ""); }); }); } }; })(Drupal, window.jQuery);;
"use strict"; (function (a, b) { a.behaviors.newsSplide = { attach: function (a) { b("news-slider-initialized", "[data-drupal-selector=\"news-slider\"]", a).forEach(function (a) { var b = new window.Splide(a, { type: "loop", drag: "free", focus: "left", perPage: 3.5, perMove: 1, arrows: !0, mediaQuery: "min", breakpoints: { 992: { gap: "1.5rem", pagination: !1, dots: !1, perPage: 3.5 }, 320: { gap: "1rem", pagination: !0, dots: !0, perPage: 1.5 } } }); b.mount(); }); } }; })(Drupal, once);;
"use strict"; (function (a, b) { a.behaviors.specialityCards = { attach: function (a) { b("specialityCardsInit", "[data-drupal-selector=\"speciality-card\"]", a).forEach(function (a) { var b = a.querySelector(".speciality-card__more-btn"); b && b.addEventListener("click", function (a) { var b = a.target.closest(".speciality-card__tags"), c = a.target.closest(".speciality-card__tag"); b && b.classList.add("active-rest"), c && c.classList.add("active"); }); }); } }; })(Drupal, once);;
function r(n, t) { for (var i = 0; i < t.length; i++) { var r = t[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r) } } function Jt(n, t, i) { t && r(n.prototype, t), i && r(n, i), Object.defineProperty(n, "prototype", { writable: !1 }) }
/*!
 * Splide.js
 * Version  : 4.1.2
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
 */
var n, t; n = this, t = function () { "use strict"; var v = "(prefers-reduced-motion: reduce)", G = 4, rn = 5, r = { CREATED: 1, MOUNTED: 2, IDLE: 3, MOVING: G, SCROLLING: rn, DRAGGING: 6, DESTROYED: 7 }; function D(n) { n.length = 0 } function o(n, t, i) { return Array.prototype.slice.call(n, t, i) } function R(n) { return n.bind.apply(n, [null].concat(o(arguments, 1))) } function on() { } var p = setTimeout; function h(n) { return requestAnimationFrame(n) } function u(n, t) { return typeof t === n } function un(n) { return !c(n) && u("object", n) } var e = Array.isArray, x = R(u, "function"), C = R(u, "string"), en = R(u, "undefined"); function c(n) { return null === n } function m(n) { try { return n instanceof (n.ownerDocument.defaultView || window).HTMLElement } catch (n) { return !1 } } function y(n) { return e(n) ? n : [n] } function g(n, t) { y(n).forEach(t) } function b(n, t) { return -1 < n.indexOf(t) } function k(n, t) { return n.push.apply(n, y(t)), n } function A(t, n, i) { t && g(n, function (n) { n && t.classList[i ? "add" : "remove"](n) }) } function M(n, t) { A(n, C(t) ? t.split(" ") : t, !0) } function L(n, t) { g(t, n.appendChild.bind(n)) } function O(n, i) { g(n, function (n) { var t = (i || n).parentNode; t && t.insertBefore(n, i) }) } function cn(n, t) { return m(n) && (n.msMatchesSelector || n.matches).call(n, t) } function S(n, t) { n = n ? o(n.children) : []; return t ? n.filter(function (n) { return cn(n, t) }) : n } function fn(n, t) { return t ? S(n, t)[0] : n.firstElementChild } var E = Object.keys; function w(t, i, n) { t && (n ? E(t).reverse() : E(t)).forEach(function (n) { "__proto__" !== n && i(t[n], n) }) } function an(r) { return o(arguments, 1).forEach(function (i) { w(i, function (n, t) { r[t] = i[t] }) }), r } function d(i) { return o(arguments, 1).forEach(function (n) { w(n, function (n, t) { e(n) ? i[t] = n.slice() : un(n) ? i[t] = d({}, un(i[t]) ? i[t] : {}, n) : i[t] = n }) }), i } function sn(t, n) { g(n || E(t), function (n) { delete t[n] }) } function P(n, i) { g(n, function (t) { g(i, function (n) { t && t.removeAttribute(n) }) }) } function I(i, t, r) { un(t) ? w(t, function (n, t) { I(i, t, n) }) : g(i, function (n) { c(r) || "" === r ? P(n, t) : n.setAttribute(t, String(r)) }) } function j(n, t, i) { n = document.createElement(n); return t && (C(t) ? M : I)(n, t), i && L(i, n), n } function _(n, t, i) { if (en(i)) return getComputedStyle(n)[t]; c(i) || (n.style[t] = "" + i) } function ln(n, t) { _(n, "display", t) } function dn(n) { n.setActive && n.setActive() || n.focus({ preventScroll: !0 }) } function z(n, t) { return n.getAttribute(t) } function vn(n, t) { return n && n.classList.contains(t) } function N(n) { return n.getBoundingClientRect() } function T(n) { g(n, function (n) { n && n.parentNode && n.parentNode.removeChild(n) }) } function hn(n) { return fn((new DOMParser).parseFromString(n, "text/html").body) } function F(n, t) { n.preventDefault(), t && (n.stopPropagation(), n.stopImmediatePropagation()) } function pn(n, t) { return n && n.querySelector(t) } function gn(n, t) { return t ? o(n.querySelectorAll(t)) : [] } function X(n, t) { A(n, t, !1) } function mn(n) { return n.timeStamp } function W(n) { return C(n) ? n : n ? n + "px" : "" } var yn = "splide", f = "data-" + yn; function bn(n, t) { if (!n) throw new Error("[" + yn + "] " + (t || "")) } var Y = Math.min, wn = Math.max, xn = Math.floor, kn = Math.ceil, U = Math.abs; function Sn(n, t, i) { return U(n - t) < i } function En(n, t, i, r) { var o = Y(t, i), t = wn(t, i); return r ? o < n && n < t : o <= n && n <= t } function q(n, t, i) { var r = Y(t, i), t = wn(t, i); return Y(wn(r, n), t) } function Ln(n) { return (0 < n) - (n < 0) } function On(t, n) { return g(n, function (n) { t = t.replace("%s", "" + n) }), t } function An(n) { return n < 10 ? "0" + n : "" + n } var _n = {}; function zn() { var c = []; function i(n, i, r) { g(n, function (t) { t && g(i, function (n) { n.split(" ").forEach(function (n) { n = n.split("."); r(t, n[0], n[1]) }) }) }) } return { bind: function (n, t, u, e) { i(n, t, function (n, t, i) { var r = "addEventListener" in n, o = r ? n.removeEventListener.bind(n, t, u, e) : n.removeListener.bind(n, u); r ? n.addEventListener(t, u, e) : n.addListener(u), c.push([n, t, i, u, o]) }) }, unbind: function (n, t, o) { i(n, t, function (t, i, r) { c = c.filter(function (n) { return !!(n[0] !== t || n[1] !== i || n[2] !== r || o && n[3] !== o) || (n[4](), !1) }) }) }, dispatch: function (n, t, i) { var r; return "function" == typeof CustomEvent ? r = new CustomEvent(t, { bubbles: !0, detail: i }) : (r = document.createEvent("CustomEvent")).initCustomEvent(t, !0, !1, i), n.dispatchEvent(r), r }, destroy: function () { c.forEach(function (n) { n[4]() }), D(c) } } } var B = "mounted", H = "move", Dn = "moved", Mn = "click", Pn = "active", In = "inactive", Rn = "visible", Cn = "hidden", J = "refresh", K = "updated", jn = "resize", Nn = "resized", Tn = "scroll", V = "scrolled", a = "destroy", Gn = "navigation:mounted", Fn = "autoplay:play", Xn = "autoplay:pause", Wn = "lazyload:loaded", Yn = "sk", Un = "sh"; function Q(n) { var i = n ? n.event.bus : document.createDocumentFragment(), r = zn(); return n && n.event.on(a, r.destroy), an(r, { bus: i, on: function (n, t) { r.bind(i, y(n).join(" "), function (n) { t.apply(t, e(n.detail) ? n.detail : []) }) }, off: R(r.unbind, i), emit: function (n) { r.dispatch(i, n, o(arguments, 1)) } }) } function qn(t, n, i, r) { var o, u, e = Date.now, c = 0, f = !0, a = 0; function s() { if (!f) { if (c = t ? Y((e() - o) / t, 1) : 1, i && i(c), 1 <= c && (n(), o = e(), r && ++a >= r)) return l(); u = h(s) } } function l() { f = !0 } function d() { u && cancelAnimationFrame(u), f = !(u = c = 0) } return { start: function (n) { n || d(), o = e() - (n ? c * t : 0), f = !1, u = h(s) }, rewind: function () { o = e(), c = 0, i && i(c) }, pause: l, cancel: d, set: function (n) { t = n }, isPaused: function () { return f } } } function s(n) { var t = n; return { set: function (n) { t = n }, is: function (n) { return b(y(n), t) } } } var n = "Arrow", Bn = n + "Left", Hn = n + "Right", t = n + "Up", n = n + "Down", Jn = "ttb", l = { width: ["height"], left: ["top", "right"], right: ["bottom", "left"], x: ["y"], X: ["Y"], Y: ["X"], ArrowLeft: [t, Hn], ArrowRight: [n, Bn] }; var Z = "role", $ = "tabindex", i = "aria-", Kn = i + "controls", Vn = i + "current", Qn = i + "selected", nn = i + "label", Zn = i + "labelledby", $n = i + "hidden", nt = i + "orientation", tt = i + "roledescription", it = i + "live", rt = i + "busy", ot = i + "atomic", ut = [Z, $, "disabled", Kn, Vn, nn, Zn, $n, nt, tt], i = yn + "__", et = yn, ct = i + "track", ft = i + "list", at = i + "slide", st = at + "--clone", lt = at + "__container", dt = i + "arrows", vt = i + "arrow", ht = vt + "--prev", pt = vt + "--next", gt = i + "pagination", mt = gt + "__page", yt = i + "progress" + "__bar", bt = i + "toggle", wt = i + "sr", tn = "is-active", xt = "is-prev", kt = "is-next", St = "is-visible", Et = "is-loading", Lt = "is-focus-in", Ot = "is-overflow", At = [tn, St, xt, kt, Et, Lt, Ot]; var _t = "touchstart mousedown", zt = "touchmove mousemove", Dt = "touchend touchcancel mouseup click"; var Mt = "slide", Pt = "loop", It = "fade"; function Rt(o, r, t, u) { var e, n = Q(o), i = n.on, c = n.emit, f = n.bind, a = o.Components, s = o.root, l = o.options, d = l.isNavigation, v = l.updateOnMove, h = l.i18n, p = l.pagination, g = l.slideFocus, m = a.Direction.resolve, y = z(u, "style"), b = z(u, nn), w = -1 < t, x = fn(u, "." + lt); function k() { var n = o.splides.map(function (n) { n = n.splide.Components.Slides.getAt(r); return n ? n.slide.id : "" }).join(" "); I(u, nn, On(h.slideX, (w ? t : r) + 1)), I(u, Kn, n), I(u, Z, g ? "button" : ""), g && P(u, tt) } function S() { e || E() } function E() { var n, t, i; e || (n = o.index, (i = L()) !== vn(u, tn) && (A(u, tn, i), I(u, Vn, d && i || ""), c(i ? Pn : In, O)), i = function () { if (o.is(It)) return L(); var n = N(a.Elements.track), t = N(u), i = m("left", !0), r = m("right", !0); return xn(n[i]) <= kn(t[i]) && xn(t[r]) <= kn(n[r]) }(), t = !i && (!L() || w), o.state.is([G, rn]) || I(u, $n, t || ""), I(gn(u, l.focusableNodes || ""), $, t ? -1 : ""), g && I(u, $, t ? -1 : 0), i !== vn(u, St) && (A(u, St, i), c(i ? Rn : Cn, O)), i || document.activeElement !== u || (t = a.Slides.getAt(o.index)) && dn(t.slide), A(u, xt, r === n - 1), A(u, kt, r === n + 1)) } function L() { var n = o.index; return n === r || l.cloneStatus && n === t } var O = { index: r, slideIndex: t, slide: u, container: x, isClone: w, mount: function () { w || (u.id = s.id + "-slide" + An(r + 1), I(u, Z, p ? "tabpanel" : "group"), I(u, tt, h.slide), I(u, nn, b || On(h.slideLabel, [r + 1, o.length]))), f(u, "click", R(c, Mn, O)), f(u, "keydown", R(c, Yn, O)), i([Dn, Un, V], E), i(Gn, k), v && i(H, S) }, destroy: function () { e = !0, n.destroy(), X(u, At), P(u, ut), I(u, "style", y), I(u, nn, b || "") }, update: E, style: function (n, t, i) { _(i && x || u, n, t) }, isWithin: function (n, t) { return n = U(n - r), (n = w || !l.rewind && !o.is(Pt) ? n : Y(n, o.length - n)) <= t } }; return O } var Ct = f + "-interval"; var jt = { passive: !1, capture: !0 }; var Nt = { Spacebar: " ", Right: Hn, Left: Bn, Up: t, Down: n }; function Tt(n) { return n = C(n) ? n : n.key, Nt[n] || n } var Gt = "keydown"; var Ft = f + "-lazy", Xt = Ft + "-srcset", Wt = "[" + Ft + "], [" + Xt + "]"; var Yt = [" ", "Enter"]; var Ut = Object.freeze({ __proto__: null, Media: function (r, n, o) { var u = r.state, t = o.breakpoints || {}, e = o.reducedMotion || {}, i = zn(), c = []; function f(n) { n && i.destroy() } function a(n, t) { t = matchMedia(t); i.bind(t, "change", s), c.push([n, t]) } function s() { var n = u.is(7), t = o.direction, i = c.reduce(function (n, t) { return d(n, t[1].matches ? t[0] : {}) }, {}); sn(o), l(i), o.destroy ? r.destroy("completely" === o.destroy) : n ? (f(!0), r.mount()) : t !== o.direction && r.refresh() } function l(n, t, i) { d(o, n), t && d(Object.getPrototypeOf(o), n), !i && u.is(1) || r.emit(K, o) } return { setup: function () { var i = "min" === o.mediaQuery; E(t).sort(function (n, t) { return i ? +n - +t : +t - +n }).forEach(function (n) { a(t[n], "(" + (i ? "min" : "max") + "-width:" + n + "px)") }), a(e, v), s() }, destroy: f, reduce: function (n) { matchMedia(v).matches && (n ? d(o, e) : sn(o, E(e))) }, set: l } }, Direction: function (n, t, o) { return { resolve: function (n, t, i) { var r = "rtl" !== (i = i || o.direction) || t ? i === Jn ? 0 : -1 : 1; return l[n] && l[n][r] || n.replace(/width|left|right/i, function (n, t) { n = l[n.toLowerCase()][r] || n; return 0 < t ? n.charAt(0).toUpperCase() + n.slice(1) : n }) }, orient: function (n) { return n * ("rtl" === o.direction ? 1 : -1) } } }, Elements: function (n, t, i) { var r, o, u, e = Q(n), c = e.on, f = e.bind, a = n.root, s = i.i18n, l = {}, d = [], v = [], h = []; function p() { r = y("." + ct), o = fn(r, "." + ft), bn(r && o, "A track/list element is missing."), k(d, S(o, "." + at + ":not(." + st + ")")), w({ arrows: dt, pagination: gt, prev: ht, next: pt, bar: yt, toggle: bt }, function (n, t) { l[t] = y("." + n) }), an(l, { root: a, track: r, list: o, slides: d }); var n = a.id || function (n) { return "" + n + An(_n[n] = (_n[n] || 0) + 1) }(yn), t = i.role; a.id = n, r.id = r.id || n + "-track", o.id = o.id || n + "-list", !z(a, Z) && "SECTION" !== a.tagName && t && I(a, Z, t), I(a, tt, s.carousel), I(o, Z, "presentation"), m() } function g(n) { var t = ut.concat("style"); D(d), X(a, v), X(r, h), P([r, o], t), P(a, n ? t : ["style", tt]) } function m() { X(a, v), X(r, h), v = b(et), h = b(ct), M(a, v), M(r, h), I(a, nn, i.label), I(a, Zn, i.labelledby) } function y(n) { n = pn(a, n); return n && function (n, t) { if (x(n.closest)) return n.closest(t); for (var i = n; i && 1 === i.nodeType && !cn(i, t);)i = i.parentElement; return i }(n, "." + et) === a ? n : void 0 } function b(n) { return [n + "--" + i.type, n + "--" + i.direction, i.drag && n + "--draggable", i.isNavigation && n + "--nav", n === et && tn] } return an(l, { setup: p, mount: function () { c(J, g), c(J, p), c(K, m), f(document, _t + " keydown", function (n) { u = "keydown" === n.type }, { capture: !0 }), f(a, "focusin", function () { A(a, Lt, !!u) }) }, destroy: g }) }, Slides: function (r, o, u) { var n = Q(r), t = n.on, e = n.emit, c = n.bind, f = (n = o.Elements).slides, a = n.list, s = []; function i() { f.forEach(function (n, t) { d(n, t, -1) }) } function l() { h(function (n) { n.destroy() }), D(s) } function d(n, t, i) { t = Rt(r, t, i, n); t.mount(), s.push(t), s.sort(function (n, t) { return n.index - t.index }) } function v(n) { return n ? p(function (n) { return !n.isClone }) : s } function h(n, t) { v(t).forEach(n) } function p(t) { return s.filter(x(t) ? t : function (n) { return C(t) ? cn(n.slide, t) : b(y(t), n.index) }) } return { mount: function () { i(), t(J, l), t(J, i) }, destroy: l, update: function () { h(function (n) { n.update() }) }, register: d, get: v, getIn: function (n) { var t = o.Controller, i = t.toIndex(n), r = t.hasFocus() ? 1 : u.perPage; return p(function (n) { return En(n.index, i, i + r - 1) }) }, getAt: function (n) { return p(n)[0] }, add: function (n, o) { g(n, function (n) { var t, i, r; m(n = C(n) ? hn(n) : n) && ((t = f[o]) ? O(n, t) : L(a, n), M(n, u.classes.slide), t = n, i = R(e, jn), t = gn(t, "img"), (r = t.length) ? t.forEach(function (n) { c(n, "load error", function () { --r || i() }) }) : i()) }), e(J) }, remove: function (n) { T(p(n).map(function (n) { return n.slide })), e(J) }, forEach: h, filter: p, style: function (t, i, r) { h(function (n) { n.style(t, i, r) }) }, getLength: function (n) { return (n ? f : s).length }, isEnough: function () { return s.length > u.perPage } } }, Layout: function (t, n, i) { var r, o, u, e = (a = Q(t)).on, c = a.bind, f = a.emit, a = n.Slides, s = n.Direction.resolve, l = (n = n.Elements).root, d = n.track, v = n.list, h = a.getAt, p = a.style; function g() { r = i.direction === Jn, _(l, "maxWidth", W(i.width)), _(d, s("paddingLeft"), y(!1)), _(d, s("paddingRight"), y(!0)), m(!0) } function m(n) { var t = N(l); !n && o.width === t.width && o.height === t.height || (_(d, "height", function () { var n = ""; r && (bn(n = b(), "height or heightRatio is missing."), n = "calc(" + n + " - " + y(!1) + " - " + y(!0) + ")"); return n }()), p(s("marginRight"), W(i.gap)), p("width", i.autoWidth ? null : W(i.fixedWidth) || (r ? "" : w())), p("height", W(i.fixedHeight) || (r ? i.autoHeight ? null : w() : b()), !0), o = t, f(Nn), u !== (u = O()) && (A(l, Ot, u), f("overflow", u))) } function y(n) { var t = i.padding, n = s(n ? "right" : "left"); return t && W(t[n] || (un(t) ? 0 : t)) || "0px" } function b() { return W(i.height || N(v).width * i.heightRatio) } function w() { var n = W(i.gap); return "calc((100%" + (n && " + " + n) + ")/" + (i.perPage || 1) + (n && " - " + n) + ")" } function x() { return N(v)[s("width")] } function k(n, t) { n = h(n || 0); return n ? N(n.slide)[s("width")] + (t ? 0 : L()) : 0 } function S(n, t) { var i, n = h(n); return n ? (n = N(n.slide)[s("right")], i = N(v)[s("left")], U(n - i) + (t ? 0 : L())) : 0 } function E(n) { return S(t.length - 1) - S(0) + k(0, n) } function L() { var n = h(0); return n && parseFloat(_(n.slide, s("marginRight"))) || 0 } function O() { return t.is(It) || E(!0) > x() } return { mount: function () { var n, t, i; g(), c(window, "resize load", (n = R(f, jn), i = qn(t || 0, n, null, 1), function () { i.isPaused() && i.start() })), e([K, J], g), e(jn, m) }, resize: m, listSize: x, slideSize: k, sliderSize: E, totalSize: S, getPadding: function (n) { return parseFloat(_(d, s("padding" + (n ? "Right" : "Left")))) || 0 }, isOverflow: O } }, Clones: function (c, i, f) { var t, r = Q(c), n = r.on, a = i.Elements, s = i.Slides, o = i.Direction.resolve, l = []; function u() { if (n(J, d), n([K, jn], v), t = h()) { var o = t, u = s.get().slice(), e = u.length; if (e) { for (; u.length < o;)k(u, u); k(u.slice(-o), u.slice(0, o)).forEach(function (n, t) { var i = t < o, r = function (n, t) { n = n.cloneNode(!0); return M(n, f.classes.clone), n.id = c.root.id + "-clone" + An(t + 1), n }(n.slide, t); i ? O(r, u[0].slide) : L(a.list, r), k(l, r), s.register(r, t - o + (i ? 0 : e), n.index) }) } i.Layout.resize(!0) } } function d() { e(), u() } function e() { T(l), D(l), r.destroy() } function v() { var n = h(); t !== n && (t < n || !n) && r.emit(J) } function h() { var n, t = f.clones; return c.is(Pt) ? en(t) && (t = (n = f[o("fixedWidth")] && i.Layout.slideSize(0)) && kn(N(a.track)[o("width")] / n) || f[o("autoWidth")] && c.length || 2 * f.perPage) : t = 0, t } return { mount: u, destroy: e } }, Move: function (r, c, o) { var e, n = Q(r), t = n.on, f = n.emit, a = r.state.set, u = (n = c.Layout).slideSize, i = n.getPadding, s = n.totalSize, l = n.listSize, d = n.sliderSize, v = (n = c.Direction).resolve, h = n.orient, p = (n = c.Elements).list, g = n.track; function m() { c.Controller.isBusy() || (c.Scroll.cancel(), y(r.index), c.Slides.update()) } function y(n) { b(S(n, !0)) } function b(n, t) { r.is(It) || (t = t ? n : function (n) { { var t, i; r.is(Pt) && (t = k(n), i = t > c.Controller.getEnd(), (t < 0 || i) && (n = w(n, i))) } return n }(n), _(p, "transform", "translate" + v("X") + "(" + t + "px)"), n !== t && f(Un)) } function w(n, t) { var i = n - L(t), r = d(); return n -= h(r * (kn(U(i) / r) || 1)) * (t ? 1 : -1) } function x() { b(E(), !0), e.cancel() } function k(n) { for (var t = c.Slides.get(), i = 0, r = 1 / 0, o = 0; o < t.length; o++) { var u = t[o].index, e = U(S(u, !0) - n); if (!(e <= r)) break; r = e, i = u } return i } function S(n, t) { var i = h(s(n - 1) - (n = n, "center" === (i = o.focus) ? (l() - u(n, !0)) / 2 : +i * u(n) || 0)); return t ? (n = i, n = o.trimSpace && r.is(Mt) ? q(n, 0, h(d(!0) - l())) : n) : i } function E() { var n = v("left"); return N(p)[n] - N(g)[n] + h(i(!1)) } function L(n) { return S(n ? c.Controller.getEnd() : 0, !!o.trimSpace) } return { mount: function () { e = c.Transition, t([B, Nn, K, J], m) }, move: function (n, t, i, r) { var o, u; n !== t && (o = i < n, u = h(w(E(), o)), o ? 0 <= u : u <= p[v("scrollWidth")] - N(g)[v("width")]) && (x(), b(w(E(), i < n), !0)), a(G), f(H, t, i, n), e.start(t, function () { a(3), f(Dn, t, i, n), r && r() }) }, jump: y, translate: b, shift: w, cancel: x, toIndex: k, toPosition: S, getPosition: E, getLimit: L, exceededLimit: function (n, t) { t = en(t) ? E() : t; var i = !0 !== n && h(t) < h(L(!1)), n = !1 !== n && h(t) > h(L(!0)); return i || n }, reposition: m } }, Controller: function (o, u, e) { var c, f, a, s, n = Q(o), t = n.on, i = n.emit, l = u.Move, d = l.getPosition, r = l.getLimit, v = l.toPosition, h = (n = u.Slides).isEnough, p = n.getLength, g = e.omitEnd, m = o.is(Pt), y = o.is(Mt), b = R(L, !1), w = R(L, !0), x = e.start || 0, k = x; function S() { f = p(!0), a = e.perMove, s = e.perPage, c = _(); var n = q(x, 0, g ? c : f - 1); n !== x && (x = n, l.reposition()) } function E() { c !== _() && i("ei") } function L(n, t) { var i = a || (P() ? 1 : s), i = O(x + i * (n ? -1 : 1), x, !(a || P())); return -1 === i && y && !Sn(d(), r(!n), 1) ? n ? 0 : c : t ? i : A(i) } function O(n, t, i) { var r; return h() || P() ? ((r = function (n) { if (y && "move" === e.trimSpace && n !== x) for (var t = d(); t === v(n, !0) && En(n, 0, o.length - 1, !e.rewind);)n < x ? --n : ++n; return n }(n)) !== n && (t = n, n = r, i = !1), n < 0 || c < n ? n = a || !En(0, n, t, !0) && !En(c, t, n, !0) ? m ? i ? n < 0 ? -(f % s || s) : f : n : e.rewind ? n < 0 ? c : 0 : -1 : z(D(n)) : i && n !== t && (n = z(D(t) + (n < t ? -1 : 1)))) : n = -1, n } function A(n) { return m ? (n + f) % f || 0 : n } function _() { for (var n = f - (P() || m && a ? 1 : s); g && 0 < n--;)if (v(f - 1, !0) !== v(n, !0)) { n++; break } return q(n, 0, f - 1) } function z(n) { return q(P() ? n : s * n, 0, c) } function D(n) { return P() ? Y(n, c) : xn((c <= n ? f - 1 : n) / s) } function M(n) { n !== x && (k = x, x = n) } function P() { return !en(e.focus) || e.isNavigation } function I() { return o.state.is([G, rn]) && !!e.waitForTransition } return { mount: function () { S(), t([K, J, "ei"], S), t(Nn, E) }, go: function (n, t, i) { var r; I() || -1 < (r = A(n = function (n) { var t = x; { var i, r; C(n) ? (r = n.match(/([+\-<>])(\d+)?/) || [], i = r[1], r = r[2], "+" === i || "-" === i ? t = O(x + +("" + i + (+r || 1)), x) : ">" === i ? t = r ? z(+r) : b(!0) : "<" === i && (t = w(!0))) : t = m ? n : q(n, 0, c) } return t }(n))) && (t || r !== x) && (M(r), l.move(n, r, k, i)) }, scroll: function (n, t, i, r) { u.Scroll.scroll(n, t, i, function () { var n = A(l.toIndex(d())); M(g ? Y(n, c) : n), r && r() }) }, getNext: b, getPrev: w, getAdjacent: L, getEnd: _, setIndex: M, getIndex: function (n) { return n ? k : x }, toIndex: z, toPage: D, toDest: function (n) { return n = l.toIndex(n), y ? q(n, 0, c) : n }, hasFocus: P, isBusy: I } }, Arrows: function (o, n, t) { var i, r, u = Q(o), e = u.on, c = u.bind, f = u.emit, a = t.classes, s = t.i18n, l = n.Elements, d = n.Controller, v = l.arrows, h = l.track, p = v, g = l.prev, m = l.next, y = {}; function b() { var n = t.arrows; !n || g && m || (p = v || j("div", a.arrows), g = S(!0), m = S(!1), i = !0, L(p, [g, m]), v || O(p, h)), g && m && (an(y, { prev: g, next: m }), ln(p, n ? "" : "none"), M(p, r = dt + "--" + t.direction), n && (e([B, Dn, J, V, "ei"], E), c(m, "click", R(k, ">")), c(g, "click", R(k, "<")), E(), I([g, m], Kn, h.id), f("arrows:mounted", g, m))), e(K, w) } function w() { x(), b() } function x() { u.destroy(), X(p, r), i ? (T(v ? [g, m] : p), g = m = null) : P([g, m], ut) } function k(n) { d.go(n, !0) } function S(n) { return hn('<button class="' + a.arrow + " " + (n ? a.prev : a.next) + '" type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40" width="40" height="40" focusable="false"><path d="' + (t.arrowPath || "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z") + '" />') } function E() { var n, t, i, r; g && m && (r = o.index, n = d.getPrev(), t = d.getNext(), i = -1 < n && r < n ? s.last : s.prev, r = -1 < t && t < r ? s.first : s.next, g.disabled = n < 0, m.disabled = t < 0, I(g, nn, i), I(m, nn, r), f("arrows:updated", g, m, n, t)) } return { arrows: y, mount: b, destroy: x, update: E } }, Autoplay: function (n, t, i) { var r, o, u = Q(n), e = u.on, c = u.bind, f = u.emit, a = qn(i.interval, n.go.bind(n, ">"), function (n) { var t = l.bar; t && _(t, "width", 100 * n + "%"), f("autoplay:playing", n) }), s = a.isPaused, l = t.Elements, d = (u = t.Elements).root, v = u.toggle, h = i.autoplay, p = "pause" === h; function g() { s() && t.Slides.isEnough() && (a.start(!i.resetProgress), o = r = p = !1, b(), f(Fn)) } function m(n) { p = !!(n = void 0 === n ? !0 : n), b(), s() || (a.pause(), f(Xn)) } function y() { p || (r || o ? m(!1) : g()) } function b() { v && (A(v, tn, !p), I(v, nn, i.i18n[p ? "play" : "pause"])) } function w(n) { n = t.Slides.getAt(n); a.set(n && +z(n.slide, Ct) || i.interval) } return { mount: function () { h && (i.pauseOnHover && c(d, "mouseenter mouseleave", function (n) { r = "mouseenter" === n.type, y() }), i.pauseOnFocus && c(d, "focusin focusout", function (n) { o = "focusin" === n.type, y() }), v && c(v, "click", function () { p ? g() : m(!0) }), e([H, Tn, J], a.rewind), e(H, w), v && I(v, Kn, l.track.id), p || g(), b()) }, destroy: a.cancel, play: g, pause: m, isPaused: s } }, Cover: function (n, t, i) { var r = Q(n).on; function o(i) { t.Slides.forEach(function (n) { var t = fn(n.container || n.slide, "img"); t && t.src && u(i, t, n) }) } function u(n, t, i) { i.style("background", n ? 'center/cover no-repeat url("' + t.src + '")' : "", !0), ln(t, n ? "none" : "") } return { mount: function () { i.cover && (r(Wn, R(u, !0)), r([B, K, J], R(o, !0))) }, destroy: R(o, !1) } }, Scroll: function (n, c, u) { var f, a, t = Q(n), i = t.on, s = t.emit, l = n.state.set, d = c.Move, v = d.getPosition, e = d.getLimit, h = d.exceededLimit, p = d.translate, g = n.is(Mt), m = 1; function y(n, t, i, r, o) { var u, e = v(), i = (x(), !i || g && h() || (i = c.Layout.sliderSize(), u = Ln(n) * i * xn(U(n) / i) || 0, n = d.toPosition(c.Controller.toDest(n % i)) + u), Sn(e, n, 1)); m = 1, t = i ? 0 : t || wn(U(n - e) / 1.5, 800), a = r, f = qn(t, b, R(w, e, n, o), 1), l(rn), s(Tn), f.start() } function b() { l(3), a && a(), s(V) } function w(n, t, i, r) { var o = v(), r = (n + (t - n) * (t = r, (n = u.easingFunc) ? n(t) : 1 - Math.pow(1 - t, 4)) - o) * m; p(o + r), g && !i && h() && (m *= .6, U(r) < 10 && y(e(h(!0)), 600, !1, a, !0)) } function x() { f && f.cancel() } function r() { f && !f.isPaused() && (x(), b()) } return { mount: function () { i(H, x), i([K, J], r) }, destroy: x, scroll: y, cancel: r } }, Drag: function (e, o, c) { var f, t, u, a, s, l, d, v, n = Q(e), i = n.on, h = n.emit, p = n.bind, g = n.unbind, m = e.state, y = o.Move, b = o.Scroll, w = o.Controller, x = o.Elements.track, k = o.Media.reduce, r = (n = o.Direction).resolve, S = n.orient, E = y.getPosition, L = y.exceededLimit, O = !1; function j() { var n = c.drag; C(!n), a = "free" === n } function N(n) { var t, i, r; l = !1, d || (t = R(n), i = n.target, r = c.noDrag, cn(i, "." + mt + ", ." + vt) || r && cn(i, r) || !t && n.button || (w.isBusy() ? F(n, !0) : (v = t ? x : window, s = m.is([G, rn]), u = null, p(v, zt, A, jt), p(v, Dt, _, jt), y.cancel(), b.cancel(), z(n)))) } function A(n) { var t, i, r, o, u; m.is(6) || (m.set(6), h("drag")), n.cancelable && (s ? (y.translate(f + D(n) / (O && e.is(Mt) ? 5 : 1)), u = 200 < M(n), t = O !== (O = L()), (u || t) && z(n), l = !0, h("dragging"), F(n)) : U(D(u = n)) > U(D(u, !0)) && (t = n, i = c.dragMinThreshold, r = un(i), o = r && i.mouse || 0, r = (r ? i.touch : +i) || 10, s = U(D(t)) > (R(t) ? r : o), F(n))) } function _(n) { var t, i, r; m.is(6) && (m.set(3), h("dragged")), s && (i = function (n) { return E() + Ln(n) * Y(U(n) * (c.flickPower || 600), a ? 1 / 0 : o.Layout.listSize() * (c.flickMaxPages || 1)) }(t = function (n) { if (e.is(Pt) || !O) { var t = M(n); if (t && t < 200) return D(n) / t } return 0 }(t = n)), r = c.rewind && c.rewindByDrag, k(!1), a ? w.scroll(i, 0, c.snap) : e.is(It) ? w.go(S(Ln(t)) < 0 ? r ? "<" : "-" : r ? ">" : "+") : e.is(Mt) && O && r ? w.go(L(!0) ? ">" : "<") : w.go(w.toDest(i), !0), k(!0), F(n)), g(v, zt, A), g(v, Dt, _), s = !1 } function T(n) { !d && l && F(n, !0) } function z(n) { u = t, t = n, f = E() } function D(n, t) { return I(n, t) - I(P(n), t) } function M(n) { return mn(n) - mn(P(n)) } function P(n) { return t === n && u || t } function I(n, t) { return (R(n) ? n.changedTouches[0] : n)["page" + r(t ? "Y" : "X")] } function R(n) { return "undefined" != typeof TouchEvent && n instanceof TouchEvent } function C(n) { d = n } return { mount: function () { p(x, zt, on, jt), p(x, Dt, on, jt), p(x, _t, N, jt), p(x, "click", T, { capture: !0 }), p(x, "dragstart", F), i([B, K], j) }, disable: C, isDragging: function () { return s } } }, Keyboard: function (t, n, i) { var r, o, u = Q(t), e = u.on, c = u.bind, f = u.unbind, a = t.root, s = n.Direction.resolve; function l() { var n = i.keyboard; n && (r = "global" === n ? window : a, c(r, Gt, h)) } function d() { f(r, Gt) } function v() { var n = o; o = !0, p(function () { o = n }) } function h(n) { o || ((n = Tt(n)) === s(Bn) ? t.go("<") : n === s(Hn) && t.go(">")) } return { mount: function () { l(), e(K, d), e(K, l), e(H, v) }, destroy: d, disable: function (n) { o = n } } }, LazyLoad: function (i, n, o) { var t = Q(i), r = t.on, u = t.off, e = t.bind, c = t.emit, f = "sequential" === o.lazyLoad, a = [Dn, V], s = []; function l() { D(s), n.Slides.forEach(function (r) { gn(r.slide, Wt).forEach(function (n) { var t = z(n, Ft), i = z(n, Xt); t === n.src && i === n.srcset || (t = o.classes.spinner, t = fn(i = n.parentElement, "." + t) || j("span", t, i), s.push([n, r, t]), n.src || ln(n, "none")) }) }), (f ? p : (u(a), r(a, d), d))() } function d() { (s = s.filter(function (n) { var t = o.perPage * ((o.preloadPages || 1) + 1) - 1; return !n[1].isWithin(i.index, t) || v(n) })).length || u(a) } function v(n) { var t = n[0]; M(n[1].slide, Et), e(t, "load error", R(h, n)), I(t, "src", z(t, Ft)), I(t, "srcset", z(t, Xt)), P(t, Ft), P(t, Xt) } function h(n, t) { var i = n[0], r = n[1]; X(r.slide, Et), "error" !== t.type && (T(n[2]), ln(i, ""), c(Wn, i, r), c(jn)), f && p() } function p() { s.length && v(s.shift()) } return { mount: function () { o.lazyLoad && (l(), r(J, l)) }, destroy: R(D, s), check: d } }, Pagination: function (l, n, d) { var v, h, t = Q(l), p = t.on, g = t.emit, m = t.bind, y = n.Slides, b = n.Elements, w = n.Controller, x = w.hasFocus, r = w.getIndex, e = w.go, c = n.Direction.resolve, k = b.pagination, S = []; function E() { v && (T(k ? o(v.children) : v), X(v, h), D(S), v = null), t.destroy() } function L(n) { e(">" + n, !0) } function O(n, t) { var i = S.length, r = Tt(t), o = A(), u = -1, o = (r === c(Hn, !1, o) ? u = ++n % i : r === c(Bn, !1, o) ? u = (--n + i) % i : "Home" === r ? u = 0 : "End" === r && (u = i - 1), S[u]); o && (dn(o.button), e(">" + u), F(t, !0)) } function A() { return d.paginationDirection || d.direction } function _(n) { return S[w.toPage(n)] } function z() { var n, t = _(r(!0)), i = _(r()); t && (X(n = t.button, tn), P(n, Qn), I(n, $, -1)), i && (M(n = i.button, tn), I(n, Qn, !0), I(n, $, "")), g("pagination:updated", { list: v, items: S }, t, i) } return { items: S, mount: function n() { E(), p([K, J, "ei"], n); var t = d.pagination; if (k && ln(k, t ? "" : "none"), t) { p([H, Tn, V], z); var t = l.length, i = d.classes, r = d.i18n, o = d.perPage, u = x() ? w.getEnd() + 1 : kn(t / o); M(v = k || j("ul", i.pagination, b.track.parentElement), h = gt + "--" + A()), I(v, Z, "tablist"), I(v, nn, r.select), I(v, nt, A() === Jn ? "vertical" : ""); for (var e = 0; e < u; e++) { var c = j("li", null, v), f = j("button", { class: i.page, type: "button" }, c), a = y.getIn(e).map(function (n) { return n.slide.id }), s = !x() && 1 < o ? r.pageX : r.slideX; m(f, "click", R(L, e)), d.paginationKeyboard && m(f, "keydown", R(O, e)), I(c, Z, "presentation"), I(f, Z, "tab"), I(f, Kn, a.join(" ")), I(f, nn, On(s, e + 1)), I(f, $, -1), S.push({ li: c, button: f, page: e }) } z(), g("pagination:mounted", { list: v, items: S }, _(l.index)) } }, destroy: E, getAt: _, update: z } }, Sync: function (i, n, t) { var r = t.isNavigation, o = t.slideFocus, u = []; function e() { var n, t; i.splides.forEach(function (n) { n.isParent || (f(i, n.splide), f(n.splide, i)) }), r && (n = Q(i), (t = n.on)(Mn, s), t(Yn, l), t([B, K], a), u.push(n), n.emit(Gn, i.splides)) } function c() { u.forEach(function (n) { n.destroy() }), D(u) } function f(n, r) { n = Q(n); n.on(H, function (n, t, i) { r.go(r.is(Pt) ? i : n) }), u.push(n) } function a() { I(n.Elements.list, nt, t.direction === Jn ? "vertical" : "") } function s(n) { i.go(n.index) } function l(n, t) { b(Yt, Tt(t)) && (s(n), F(t)) } return { setup: R(n.Media.set, { slideFocus: en(o) ? r : o }, !0), mount: e, destroy: c, remount: function () { c(), e() } } }, Wheel: function (e, c, f) { var n = Q(e).bind, a = 0; function t(n) { var t, i, r, o, u; n.cancelable && (t = (u = n.deltaY) < 0, i = mn(n), r = f.wheelMinThreshold || 0, o = f.wheelSleep || 0, U(u) > r && o < i - a && (e.go(t ? "<" : ">"), a = i), u = t, f.releaseWheel && !e.state.is(G) && -1 === c.Controller.getAdjacent(u) || F(n)) } return { mount: function () { f.wheel && n(c.Elements.track, "wheel", t, jt) } } }, Live: function (n, t, i) { var r = Q(n).on, o = t.Elements.track, u = i.live && !i.isNavigation, e = j("span", wt), c = qn(90, R(f, !1)); function f(n) { I(o, rt, n), n ? (L(o, e), c.start()) : (T(e), c.cancel()) } function a(n) { u && I(o, it, n ? "off" : "polite") } return { mount: function () { u && (a(!t.Autoplay.isPaused()), I(o, ot, !0), e.textContent = "", r(Fn, R(a, !0)), r(Xn, R(a, !1)), r([Dn, V], R(f, !0))) }, disable: a, destroy: function () { P(o, [it, ot, rt]), T(e) } } } }), qt = { type: "slide", role: "region", speed: 400, perPage: 1, cloneStatus: !0, arrows: !0, pagination: !0, paginationKeyboard: !0, interval: 5e3, pauseOnHover: !0, pauseOnFocus: !0, resetProgress: !0, easing: "cubic-bezier(0.25, 1, 0.5, 1)", drag: !0, direction: "ltr", trimSpace: !0, focusableNodes: "a, button, textarea, input, select, iframe", live: !0, classes: { slide: at, clone: st, arrows: dt, arrow: vt, prev: ht, next: pt, pagination: gt, page: mt, spinner: i + "spinner" }, i18n: { prev: "Previous slide", next: "Next slide", first: "Go to first slide", last: "Go to last slide", slideX: "Go to slide %s", pageX: "Go to page %s", play: "Start autoplay", pause: "Pause autoplay", carousel: "carousel", slide: "slide", select: "Select a slide to show", slideLabel: "%s of %s" }, reducedMotion: { speed: 0, rewindSpeed: 0, autoplay: "pause" } }; function Bt(n, t, i) { var r = t.Slides; function o() { r.forEach(function (n) { n.style("transform", "translateX(-" + 100 * n.index + "%)") }) } return { mount: function () { Q(n).on([B, J], o) }, start: function (n, t) { r.style("transition", "opacity " + i.speed + "ms " + i.easing), p(t) }, cancel: on } } function Ht(u, n, e) { var c, f = n.Move, a = n.Controller, s = n.Scroll, t = n.Elements.list, l = R(_, t, "transition"); function i() { l(""), s.cancel() } return { mount: function () { Q(u).bind(t, "transitionend", function (n) { n.target === t && c && (i(), c()) }) }, start: function (n, t) { var i = f.toPosition(n, !0), r = f.getPosition(), o = function (n) { var t = e.rewindSpeed; if (u.is(Mt) && t) { var i = a.getIndex(!0), r = a.getEnd(); if (0 === i && r <= n || r <= i && 0 === n) return t } return e.speed }(n); 1 <= U(i - r) && 1 <= o ? e.useScroll ? s.scroll(i, o, !1, t) : (l("transform " + o + "ms " + e.easing), f.translate(i, !0), c = t) : (f.jump(n), t()) }, cancel: i } } t = function () { function i(n, t) { this.event = Q(), this.Components = {}, this.state = s(1), this.splides = [], this.n = {}, this.t = {}; n = C(n) ? pn(document, n) : n; bn(n, n + " is invalid."), t = d({ label: z(this.root = n, nn) || "", labelledby: z(n, Zn) || "" }, qt, i.defaults, t || {}); try { d(t, JSON.parse(z(n, f))) } catch (n) { bn(!1, "Invalid JSON") } this.n = Object.create(d({}, t)) } var n = i.prototype; return n.mount = function (n, t) { var i = this, r = this.state, o = this.Components; return bn(r.is([1, 7]), "Already mounted!"), r.set(1), this.i = o, this.r = t || this.r || (this.is(It) ? Bt : Ht), this.t = n || this.t, w(an({}, Ut, this.t, { Transition: this.r }), function (n, t) { n = n(i, o, i.n); (o[t] = n).setup && n.setup() }), w(o, function (n) { n.mount && n.mount() }), this.emit(B), M(this.root, "is-initialized"), r.set(3), this.emit("ready"), this }, n.sync = function (n) { return this.splides.push({ splide: n }), n.splides.push({ splide: this, isParent: !0 }), this.state.is(3) && (this.i.Sync.remount(), n.Components.Sync.remount()), this }, n.go = function (n) { return this.i.Controller.go(n), this }, n.on = function (n, t) { return this.event.on(n, t), this }, n.off = function (n) { return this.event.off(n), this }, n.emit = function (n) { var t; return (t = this.event).emit.apply(t, [n].concat(o(arguments, 1))), this }, n.add = function (n, t) { return this.i.Slides.add(n, t), this }, n.remove = function (n) { return this.i.Slides.remove(n), this }, n.is = function (n) { return this.n.type === n }, n.refresh = function () { return this.emit(J), this }, n.destroy = function (t) { void 0 === t && (t = !0); var n = this.event, i = this.state; return i.is(1) ? Q(this).on("ready", this.destroy.bind(this, t)) : (w(this.i, function (n) { n.destroy && n.destroy(t) }, !0), n.emit(a), n.destroy(), t && D(this.splides), i.set(7)), this }, Jt(i, [{ key: "options", get: function () { return this.n }, set: function (n) { this.i.Media.set(n, !0, !0) } }, { key: "length", get: function () { return this.i.Slides.getLength(!0) } }, { key: "index", get: function () { return this.i.Controller.getIndex() } }]), i }(); return t.defaults = {}, t.STATES = r, t }, "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (n = "undefined" != typeof globalThis ? globalThis : n || self).Splide = t();

;
/*!
 * @splidejs/splide-extension-auto-scroll
 * Version  : 0.5.3
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
 */(function (S) { typeof define == "function" && define.amd ? define(S) : S() })(function () { "use strict"; function S(n) { n.length = 0 } function D(n, t, r) { return Array.prototype.slice.call(n, t, r) } function _(n) { return n.bind.apply(n, [null].concat(D(arguments, 1))) } function q(n) { return requestAnimationFrame(n) } function C(n, t) { return typeof t === n } var z = Array.isArray; _(C, "function"), _(C, "string"), _(C, "undefined"); function B(n) { return z(n) ? n : [n] } function H(n, t) { B(n).forEach(t) } var cn = Object.keys; function sn(n, t, r) { if (n) { var e = cn(n); e = r ? e.reverse() : e; for (var o = 0; o < e.length; o++) { var c = e[o]; if (c !== "__proto__" && t(n[c], c) === !1) break } } return n } function dn(n) { return D(arguments, 1).forEach(function (t) { sn(t, function (r, e) { n[e] = t[e] }) }), n } var ln = Math.min; function vn() { var n = []; function t(u, s, a, d) { o(u, s, function (f, v, l) { var h = "addEventListener" in f, w = h ? f.removeEventListener.bind(f, v, a, d) : f.removeListener.bind(f, a); h ? f.addEventListener(v, a, d) : f.addListener(a), n.push([f, v, l, a, w]) }) } function r(u, s, a) { o(u, s, function (d, f, v) { n = n.filter(function (l) { return l[0] === d && l[1] === f && l[2] === v && (!a || l[3] === a) ? (l[4](), !1) : !0 }) }) } function e(u, s, a) { var d, f = !0; return typeof CustomEvent == "function" ? d = new CustomEvent(s, { bubbles: f, detail: a }) : (d = document.createEvent("CustomEvent"), d.initCustomEvent(s, f, !1, a)), u.dispatchEvent(d), d } function o(u, s, a) { H(u, function (d) { d && H(s, function (f) { f.split(" ").forEach(function (v) { var l = v.split("."); a(d, l[0], l[1]) }) }) }) } function c() { n.forEach(function (u) { u[4]() }), S(n) } return { bind: t, unbind: r, dispatch: e, destroy: c } } var K = "move", J = "moved", En = "updated", Q = "drag", pn = "dragged", U = "scroll", W = "scrolled", mn = "destroy"; function hn(n) { var t = n ? n.event.bus : document.createDocumentFragment(), r = vn(); function e(c, u) { r.bind(t, B(c).join(" "), function (s) { u.apply(u, z(s.detail) ? s.detail : []) }) } function o(c) { r.dispatch(t, c, D(arguments, 1)) } return n && n.event.on(mn, r.destroy), dn(r, { bus: t, on: e, off: _(r.unbind, t), emit: o }) } function Y(n, t, r, e) { var o = Date.now, c, u = 0, s, a = !0, d = 0; function f() { if (!a) { if (u = n ? ln((o() - c) / n, 1) : 1, r && r(u), u >= 1 && (t(), c = o(), e && ++d >= e)) return l(); q(f) } } function v(E) { !E && w(), c = o() - (E ? u * n : 0), a = !1, q(f) } function l() { a = !0 } function h() { c = o(), u = 0, r && r(u) } function w() { s && cancelAnimationFrame(s), u = 0, s = 0, a = !0 } function M(E) { n = E } function N() { return a } return { start: v, rewind: h, pause: l, cancel: w, set: M, isPaused: N } } function An(n, t) { var r; function e() { r || (r = Y(t || 0, function () { n(), r = null }, null, 1), r.start()) } return e } var gn = "is-active", wn = "slide", yn = "fade"; function X(n, t, r) { return Array.prototype.slice.call(n, t, r) } function V(n) { return n.bind.apply(n, [null].concat(X(arguments, 1))) } function L(n, t) { return typeof t === n } function $(n) { return !Z(n) && L("object", n) } var bn = Array.isArray; V(L, "function"), V(L, "string"); var Sn = V(L, "undefined"); function Z(n) { return n === null } function _n(n) { return bn(n) ? n : [n] } function O(n, t) { _n(n).forEach(t) } function Ln(n, t, r) { n && O(t, function (e) { e && n.classList[r ? "add" : "remove"](e) }) } var On = Object.keys; function j(n, t, r) { if (n) { var e = On(n); e = r ? e.reverse() : e; for (var o = 0; o < e.length; o++) { var c = e[o]; if (c !== "__proto__" && t(n[c], c) === !1) break } } return n } function k(n) { return X(arguments, 1).forEach(function (t) { j(t, function (r, e) { n[e] = t[e] }) }), n } function Tn(n, t) { O(n, function (r) { O(t, function (e) { r && r.removeAttribute(e) }) }) } function nn(n, t, r) { $(t) ? j(t, function (e, o) { nn(n, o, e) }) : O(n, function (e) { Z(r) || r === "" ? Tn(e, t) : e.setAttribute(t, String(r)) }) } var tn = Math.min, rn = Math.max, qn = Math.floor, zn = Math.ceil, Bn = Math.abs; function Dn(n, t, r) { var e = tn(t, r), o = rn(t, r); return tn(rn(e, n), o) } var Cn = { speed: 1, autoStart: !0, pauseOnHover: !0, pauseOnFocus: !0 }, Vn = { startScroll: "Start auto scroll", pauseScroll: "Pause auto scroll" }; function $n(n, t, r) { var e = hn(n), o = e.on, c = e.off, u = e.bind, s = e.unbind, a = t.Move, d = a.translate, f = a.getPosition, v = a.toIndex, l = a.getLimit, h = t.Controller, w = h.setIndex, M = h.getIndex, N = t.Direction.orient, E = t.Elements.toggle, en = t.Live, I = n.root, Mn = An(t.Arrows.update, 500), p = {}, m, A, x, F, P, T; function Nn() { var i = r.autoScroll; p = k({}, Cn, $(i) ? i : {}) } function on() { n.is(yn) || !m && r.autoScroll !== !1 && (m = Y(0, Pn), In(), Fn()) } function un() { m && (m.cancel(), m = null, T = void 0, c([K, Q, U, J, W]), s(I, "mouseenter mouseleave focusin focusout"), s(E, "click")) } function In() { p.pauseOnHover && u(I, "mouseenter mouseleave", function (i) { x = i.type === "mouseenter", R() }), p.pauseOnFocus && u(I, "focusin focusout", function (i) { F = i.type === "focusin", R() }), p.useToggleButton && u(E, "click", function () { A ? y() : b() }), o(En, xn), o([K, Q, U], function () { P = !0, b(!1) }), o([J, pn, W], function () { P = !1, R() }) } function xn() { var i = r.autoScroll; i !== !1 ? (p = k({}, p, $(i) ? i : {}), on()) : un(), m && !Sn(T) && d(T) } function Fn() { p.autoStart && (document.readyState === "complete" ? y() : u(window, "load", y)) } function y() { G() && (m.start(!0), en.disable(!0), F = x = A = !1, an()) } function b(i) { i === void 0 && (i = !0), A || (A = i, an(), G() || (m.pause(), en.disable(!1))) } function R() { A || (x || F || P ? b(!1) : y()) } function Pn() { var i = f(), g = Rn(i); i !== g ? (d(g), Gn(T = f())) : (b(!1), p.rewind && n.go(p.speed > 0 ? 0 : t.Controller.getEnd())), Mn() } function Rn(i) { var g = p.speed || 1; return i += N(g), n.is(wn) && (i = Dn(i, l(!1), l(!0))), i } function Gn(i) { var g = n.length, fn = (v(i) + g) % g; fn !== M() && (w(fn), t.Slides.update(), t.Pagination.update(), r.lazyLoad === "nearby" && t.LazyLoad.check()) } function an() { if (E) { var i = A ? "startScroll" : "pauseScroll"; Ln(E, gn, !A), nn(E, "aria-label", r.i18n[i] || Vn[i]) } } function G() { return !m || m.isPaused() } return { setup: Nn, mount: on, destroy: un, play: y, pause: b, isPaused: G } } typeof window < "u" && (window.splide = window.splide || {}, window.splide.Extensions = window.splide.Extensions || {}, window.splide.Extensions.AutoScroll = $n) });
;
